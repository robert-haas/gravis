§PREFIX§
  <style>
    /* Main divisions */
    #§RANDOM_ID§-main-div {
      line-height: normal;
      box-sizing: content-box;
      padding: 3px;
      background-color: white;
    }
    #§RANDOM_ID§-left-div {
      float: left;
      line-height: normal;
      box-sizing: content-box;
    }
    #§RANDOM_ID§-right-div {
      float: left;
      height: 100%;
      display: none;
      line-height: normal;
      box-sizing: content-box;
    }
    #§RANDOM_ID§-right-inner-div {
      padding-left: 5px;
      padding-right: 2px;
      overflow-x: hidden;
      overflow-y: auto;
      height: 100%;
      line-height: normal;
      box-sizing: content-box;
    }

    /* Graph and details (contained in left-inner-div) */
    #§RANDOM_ID§-graph-div {
      overflow: hidden;
      resize: vertical;
      position: relative;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0px 0px 2px rgba(0, 0, 0, 0.2);
      display: none;
      line-height: normal;
      box-sizing: content-box;
    }
    #§RANDOM_ID§-details-div {
      overflow: auto;
      resize: vertical;
      margin-top: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0px 0px 2px rgba(0, 0, 0, 0.2);
      display: none;
      line-height: normal;
      box-sizing: content-box;
    }
    #§RANDOM_ID§-details-head {
      user-select: none;
      padding-left: 4px !important;
      padding-top: 4px !important;
      font-size: 8px;
      font-family: "Lucida Console", Monaco, monospace;
      color: gray;
      line-height: normal;
      box-sizing: content-box;
    }
    #§RANDOM_ID§-details-body {
      padding: 10px;
      padding-top: 6px;
      font-size: 10px;
      font-family: "Lucida Console", Monaco, monospace;
      line-height: normal;
      box-sizing: content-box;
    }

    /* Control menu (contained in right-inner-div) */
    .§RANDOM_ID§-menu-item-head {
      font-size: 11px;
      font-family: "Lucida Console", Monaco, monospace;
      color: black;
      cursor: pointer;
      padding-left: 5px;
      padding-right: 0px;
      padding-top: 5px;
      padding-bottom: 5px;
      margin-bottom: 5px;
      border-radius: 4px;
      border: 1px solid #ccc;
      box-shadow: 0px 0px 3px rgba(0, 0, 0, 0.2);
      line-height: normal;
      box-sizing: content-box;
    }
    .§RANDOM_ID§-menu-item-body {
      margin-left: 5px;
      margin-bottom: 10px;
      line-height: normal;
      box-sizing: content-box;
    }
    .§RANDOM_ID§-menu-subitem-head {
      font-size: 9px;
      font-family: "Lucida Console", Monaco, monospace;
      font-weight: 600;
      color: #006429;
      cursor: default;
      margin-bottom: 2px;
      line-height: normal;
      box-sizing: content-box;
    }
    .§RANDOM_ID§-menu-subitem-body {
      font-size: 8px;
      font-family: "Lucida Console", Monaco, monospace;
      margin-left: 7px;
      margin-bottom: 5px;
      line-height: normal;
      box-sizing: content-box;
    }
    .§RANDOM_ID§-labeled-input {
      all: initial;
      display: flex;
      align-items: center;
      margin-top: 1px;
      margin-bottom: 1px;
    }
    .§RANDOM_ID§-label {
      all: initial;
      font-size: 8px;
      font-family: "Lucida Console", Monaco, monospace;
      font-style: italic;
      cursor: pointer;
    }
    .§RANDOM_ID§-slider {
      width: 100%;
      margin-bottom: 2px;
    }
    .§RANDOM_ID§-slider::-moz-focus-outer {
      border: 0;
    }
    .§RANDOM_ID§-slider-text-left {
      font-size: 8px;
      font-family: "Lucida Console", Monaco, monospace;
      font-style: italic;
      color: black;
      float: left;
      margin-top: 2px;
    }
    .§RANDOM_ID§-slider-text-right {
      font-size: 8px;
      font-family: "Lucida Console", Monaco, monospace;
      color: black;
      float: right;
    }
    .§RANDOM_ID§-checkbox {
      margin-left: 0px !important;
      margin-right: 4px !important;
      margin-top: 2px !important;
      margin-bottom: 2px !important;
      padding: 0px !important;
    }
    .§RANDOM_ID§-select {
      cursor: pointer;
      outline: none;
      font-size: 8px;
      font-family: "Lucida Console", Monaco, monospace;
      color: black;
      background-color: #f5f5f5;
      width: 100%;
      padding-top: 4px !important;
      padding-bottom: 4px !important;
      padding-left: 5px;
      padding-right: 10px;
      margin-right: 5px;
      margin-top: 2px;
      margin-bottom: 2px;
      border-radius: 4px;
      border: 1.2px solid #bbb;
      box-shadow: 0 1px 0 1px rgba(0, 0, 0, 0.04);

      -moz-appearance: none;
      -webkit-appearance: none;
      appearance: none;
      background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyOTIuNCIgaGVpZ2h0PSIyOTIuNCI+PHBhdGggZmlsbD0iIzAwMDAwMCIgZD0iTSAtNS4yMDY0NjJlLTYsNjQuNTcyNjU2IDI5Mi4zOTk5OSw2NC41NzI2NTQgMTQ2LjE5OTk3LDIzMy42Mjg0NyAtNS4yMDY0NjJlLTYsNjQuNTcyNjU2Ii8+PC9zdmc+Cg==');
      background-repeat: no-repeat;
      background-position: right 4px top 50%;
      background-size: 6px;
    }
    @-moz-document url-prefix() {
      /* Dirty hack to remove dotted border on focus */
      .§RANDOM_ID§-select {
        color: transparent !important;
        text-shadow: 0 0 0 black !important;
      }
    }
    .§RANDOM_ID§-select:after {
      cursor: pointer;
    }
    .§RANDOM_ID§-button {
      cursor: pointer;
      outline: none;
      font-size: 8px;
      font-family: "Lucida Console", Monaco, monospace;
      color: black;
      background-color: #f2f2f2;
      padding-top: 4px !important;
      padding-bottom: 4px !important;
      padding-left: 10px;
      padding-right: 10px;
      margin-top: 2px;
      margin-bottom: 2px;
      border-radius: 4px;
      border: 1.2px solid #bbb;
      box-shadow: 0 1px 0 1px rgba(0, 0, 0, 0.04);
    }
    .§RANDOM_ID§-button:hover {
      border: 1.2px solid #999;
      background-color: #f2f2f2;
    }
    .§RANDOM_ID§-button:active {
      background-color: #ddd;
    }
    .§RANDOM_ID§-button::-moz-focus-inner {
      border: 0;
    }
    /* Hidden menu items */
    #§RANDOM_ID§-graph-select-div {
      display: none;
    }
    #§RANDOM_ID§-node-size-norm-div {
      display: none;
    }
    #§RANDOM_ID§-edge-size-norm-div {
      display: none;
    }

    /* Graph */
    #§RANDOM_ID§-tooltip-div {
      font-size: 10px;
      font-family: "Lucida Console", Monaco, monospace;
      z-index: 42001;
      opacity: 0;
      visibility: hidden;
      position: absolute !important;
      max-width: 40%;
      padding: 5px;
      white-space: pre-wrap;
      word-break: break-word;
      color: black;
      background-color: white;
      border-radius: 4px;
      border: 1px solid #ccc;
      box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.2);
      line-height: normal;
      box-sizing: content-box;
    }
    #§RANDOM_ID§-menu-toggle-button, #§RANDOM_ID§-details-toggle-button, #§RANDOM_ID§-progress-container {
      font-size: 14px;
      font-family: "Lucida Console", Monaco, monospace;
      z-index: 42000;
      cursor: pointer;
      position: absolute;
      background-color: white;
      border-radius: 4px;
      box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.2);
      line-height: normal;
      box-sizing: content-box;
    }
    #§RANDOM_ID§-menu-toggle-button {
      top: 0;
      right: 0;
      padding-left: 6px;
      padding-right: 6px;
      padding-top: 12px;
      padding-bottom: 12px;
      border-top: 0px;
      border-right: 0px;
      border-bottom: 1px solid #ccc;
      border-left: 1px solid #ccc;
    }
    #§RANDOM_ID§-details-toggle-button {
      bottom: 0;
      left: 0;
      padding-left: 19px;
      padding-right: 19px;
      padding-top: 0.5px;
      padding-bottom: 2px;
      border-top: 1px solid #ccc;
      border-right: 1px solid #ccc;
      border-bottom: 0px;
      border-left: 0px;
    }
    #§RANDOM_ID§-progress-container {
      font-size: 10px;
      text-align: center;
      top: 46%;
      left: 15%;
      width: 70%;
      padding: 8px;
      border: none;
      box-shadow: none;
    }

    /* Details */
    #§RANDOM_ID§-details-user-provided {
      margin-top: 3px;
      padding-top: 3.5px;
      border-top: 0.5px dashed black;
      line-height: normal;
      box-sizing: content-box;
      white-space: pre-wrap;
      word-break: break-word;
    }
    #§RANDOM_ID§-details-user-provided ul {
      list-style-position: inside;
      padding-left: 6px;
    }

    /* Unavailable in vis.js and therefore hidden */
    #§RANDOM_ID§-svg,
    #§RANDOM_ID§-node-label-rotation,
    #§RANDOM_ID§-edge-label-rotation {
      display: none;
    }
    /* Specific to vis.js */
    div.vis-tooltip {
      position: absolute;
      visibility: hidden;
      pointer-events: none;
      z-index: 5;
      max-width: 40%;
      white-space: pre-wrap;
      word-break: break-word;
      font-size: 10px;
      padding: 5px;
      color: black;
      background-color: white;
      -moz-border-radius: 3px;
      -webkit-border-radius: 3px;
      border-radius: 3px;
      border: 0.5px solid black;
      box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.3);
    }
  </style>

  <div id="§RANDOM_ID§-main-div">
    <div id="§RANDOM_ID§-tooltip-div"></div>

    <div id="§RANDOM_ID§-left-div">
      <div id="§RANDOM_ID§-left-inner-div">
        <div id="§RANDOM_ID§-graph-div"></div>
        <div id="§RANDOM_ID§-details-div">
          <div id="§RANDOM_ID§-details-head">
            Details for selected element
          </div>
          <div id="§RANDOM_ID§-details-body">
          </div>
        </div>
      </div>
    </div>

    <div id="§RANDOM_ID§-right-div">
      <div id="§RANDOM_ID§-right-inner-div">
        <!-- Menu: General -->
        <div class="§RANDOM_ID§-menu-item-head"
             id="§RANDOM_ID§-general-head">
          General
        </div>
        <div class="§RANDOM_ID§-menu-item-body"
             id="§RANDOM_ID§-general-body">
          <!-- Sub-menu: State -->
          <div>
            <div class="§RANDOM_ID§-menu-subitem-head">
              App state
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <button class="§RANDOM_ID§-button"
                      id="§RANDOM_ID§-reset"
                      type="button">Reset</button>
            </div>
          </div>
          <!-- Sub-menu: Display mode (fullscreen or not) -->
          <div>
            <div class="§RANDOM_ID§-menu-subitem-head">
              Display mode
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <button class="§RANDOM_ID§-button"
                      id="§RANDOM_ID§-fullscreen-button"
                      type="button">Enter full screen</button>
            </div>
          </div>
          <!-- Sub-menu: Export -->
          <div>
            <div class="§RANDOM_ID§-menu-subitem-head">
              Export
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <button class="§RANDOM_ID§-button"
                      id="§RANDOM_ID§-svg"
                      type="button">SVG</button>
              <button class="§RANDOM_ID§-button"
                      id="§RANDOM_ID§-png"
                      type="button">PNG</button>
              <button class="§RANDOM_ID§-button"
                      id="§RANDOM_ID§-jpg"
                      type="button">JPG</button>
            </div>
          </div>
        </div>
        <!-- Menu: Data -->
        <div class="§RANDOM_ID§-menu-item-head"
             id="§RANDOM_ID§-data-head">
          Data selection
        </div>
        <div class="§RANDOM_ID§-menu-item-body"
             id="§RANDOM_ID§-data-body">
          <!-- Sub-menu: Graph (only shown if multiple graphs in data) -->
          <div id="§RANDOM_ID§-graph-select-div">
            <div class="§RANDOM_ID§-menu-subitem-head">
              Graph
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <select class="§RANDOM_ID§-select"
                      id="§RANDOM_ID§-graph-select"></select>
            </div>
          </div>
          <!-- Sub-menu: Node label text -->
          <div>
            <div class="§RANDOM_ID§-menu-subitem-head">
              Node label text
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <select class="§RANDOM_ID§-select"
                      id="§RANDOM_ID§-node-label-data-source-select"></select>
            </div>
          </div>
          <!-- Sub-menu: Edge label text -->
          <div>
            <div class="§RANDOM_ID§-menu-subitem-head">
              Edge label text
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <select class="§RANDOM_ID§-select"
                      id="§RANDOM_ID§-edge-label-data-source-select"></select>
            </div>
          </div>
          <!-- Sub-menu: Node size -->
          <div class="§RANDOM_ID§-menu-subitem-head">
            Node size
          </div>
          <div class="§RANDOM_ID§-menu-subitem-body">
            <div>
              <select class="§RANDOM_ID§-select"
                      id="§RANDOM_ID§-node-size-data-source-select"></select>
            </div>
            <div class="§RANDOM_ID§-labeled-input">
              <input class="§RANDOM_ID§-checkbox"
                     id="§RANDOM_ID§-node-size-normalization-checkbox"
                     type="checkbox">
              <label class="§RANDOM_ID§-label"
                     for="§RANDOM_ID§-node-size-normalization-checkbox">Normalize</label>
            </div>
            <div id="§RANDOM_ID§-node-size-norm-div">
              <div>
                <span class="§RANDOM_ID§-slider-text-left">Minimum</span>
                <span class="§RANDOM_ID§-slider-text-right"
                      id="§RANDOM_ID§-node-size-normalization-min-text"></span>
                <input class="§RANDOM_ID§-slider"
                       id="§RANDOM_ID§-node-size-normalization-min-slider"
                       type="range" min="0.01" max="300.0" step="0.01">
              </div>
              <div>
                <span class="§RANDOM_ID§-slider-text-left">Maximum</span>
                <span class="§RANDOM_ID§-slider-text-right"
                      id="§RANDOM_ID§-node-size-normalization-max-text"></span>
                <input class="§RANDOM_ID§-slider"
                       id="§RANDOM_ID§-node-size-normalization-max-slider"
                       type="range" min="0.01" max="300.0" step="0.01">
              </div>
            </div>
          </div>
          <!-- Sub-menu: Edge size -->
          <div class="§RANDOM_ID§-menu-subitem-head">
            Edge size
          </div>
          <div class="§RANDOM_ID§-menu-subitem-body">
            <div>
              <select class="§RANDOM_ID§-select"
                      id="§RANDOM_ID§-edge-size-data-source-select"></select>
            </div>
            <div class="§RANDOM_ID§-labeled-input">
              <input class="§RANDOM_ID§-checkbox"
                     id="§RANDOM_ID§-edge-size-normalization-checkbox"
                     type="checkbox">
              <label class="§RANDOM_ID§-label"
                     for="§RANDOM_ID§-edge-size-normalization-checkbox">Normalize</label>
            </div>
            <div id="§RANDOM_ID§-edge-size-norm-div">
              <div>
                <span class="§RANDOM_ID§-slider-text-left">Minimum</span>
                <span class="§RANDOM_ID§-slider-text-right"
                      id="§RANDOM_ID§-edge-size-normalization-min-text"></span>
                <input class="§RANDOM_ID§-slider"
                       id="§RANDOM_ID§-edge-size-normalization-min-slider"
                       type="range" min="0.01" max="50.0" step="0.01">
              </div>
              <div>
                <span class="§RANDOM_ID§-slider-text-left">Maximum</span>
                <span class="§RANDOM_ID§-slider-text-right"
                      id="§RANDOM_ID§-edge-size-normalization-max-text"></span>
                <input class="§RANDOM_ID§-slider"
                       id="§RANDOM_ID§-edge-size-normalization-max-slider"
                       type="range" min="0.01" max="50.0" step="0.01">
              </div>
            </div>
          </div>
        </div>
        <!-- Menu: Nodes -->
        <div class="§RANDOM_ID§-menu-item-head"
             id="§RANDOM_ID§-node-head">
          Nodes
        </div>
        <div class="§RANDOM_ID§-menu-item-body"
             id="§RANDOM_ID§-node-body">
          <!-- Sub-menu: Visibility -->
          <div>
            <div class="§RANDOM_ID§-menu-subitem-head">
              Visibility
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <div class="§RANDOM_ID§-labeled-input">
                <input class="§RANDOM_ID§-checkbox"
                       id="§RANDOM_ID§-node-checkbox"
                       type="checkbox">
                <label class="§RANDOM_ID§-label"
                       for="§RANDOM_ID§-node-checkbox">Show nodes</label>
              </div>
            </div>
          </div>
          <!-- Sub-menu: Size -->
          <div>
            <div class="§RANDOM_ID§-menu-subitem-head">
              Size
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <div>
                <span class="§RANDOM_ID§-slider-text-left">Scaling factor</span>
                <span class="§RANDOM_ID§-slider-text-right"
                      id="§RANDOM_ID§-node-size-factor-text"></span>
                <input class="§RANDOM_ID§-slider"
                       id="§RANDOM_ID§-node-size-factor-slider"
                       type="range" min="0.01" max="5.0" step="0.01">
              </div>
            </div>
          </div>
          <!-- Sub-menu: Position -->
          <div>
            <div class="§RANDOM_ID§-menu-subitem-head">
              Position
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <button class="§RANDOM_ID§-button"
                      id="§RANDOM_ID§-node-release-button"
                      type="button">Release fixed nodes</button>
            </div>
          </div>
          <!-- Sub-menu: Drag behavior -->
          <div>
            <div class="§RANDOM_ID§-menu-subitem-head">
              Drag behavior
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <div class="§RANDOM_ID§-labeled-input">
                <input class="§RANDOM_ID§-checkbox"
                       id="§RANDOM_ID§-node-drag-fix-checkbox"
                       type="checkbox">
                <label class="§RANDOM_ID§-label"
                       for="§RANDOM_ID§-node-drag-fix-checkbox">Fix node position</label>
              </div>
            </div>
          </div>
          <!-- Sub-menu: Hover behavior -->
          <div>
            <div class="§RANDOM_ID§-menu-subitem-head">
              Hover behavior
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <div class="§RANDOM_ID§-labeled-input">
                <input class="§RANDOM_ID§-checkbox"
                       id="§RANDOM_ID§-node-hover-neighborhood-checkbox"
                       type="checkbox">
                <label class="§RANDOM_ID§-label"
                       for="§RANDOM_ID§-node-hover-neighborhood-checkbox">Show neighborhood</label>
              </div>
              <div class="§RANDOM_ID§-labeled-input">
                <input class="§RANDOM_ID§-checkbox"
                       id="§RANDOM_ID§-node-hover-tooltip-checkbox"
                       type="checkbox">
                <label class="§RANDOM_ID§-label"
                       for="§RANDOM_ID§-node-hover-tooltip-checkbox">Show tooltips (if provided)</label>
              </div>
            </div>
          </div>
        </div>
        <!-- Menu: Node images -->
        <div id="§RANDOM_ID§-node-image-meta-control">
          <div class="§RANDOM_ID§-menu-item-head"
               id="§RANDOM_ID§-node-image-head">
            Node images
          </div>
          <div class="§RANDOM_ID§-menu-item-body"
               id="§RANDOM_ID§-node-image-body">
            <!-- Sub-menu: Visibility -->
            <div>
              <div class="§RANDOM_ID§-menu-subitem-head">
                Visibility
              </div>
              <div class="§RANDOM_ID§-menu-subitem-body">
                <div class="§RANDOM_ID§-labeled-input">
                  <input class="§RANDOM_ID§-checkbox"
                         id="§RANDOM_ID§-node-image-checkbox"
                         type="checkbox">
                  <label class="§RANDOM_ID§-label"
                         for="§RANDOM_ID§-node-image-checkbox">Show node images</label>
                </div>
              </div>
            </div>
            <!-- Sub-menu: Size -->
            <div>
              <div class="§RANDOM_ID§-menu-subitem-head">
                Size
              </div>
              <div class="§RANDOM_ID§-menu-subitem-body">
                <span class="§RANDOM_ID§-slider-text-left">Scaling factor</span>
                <span class="§RANDOM_ID§-slider-text-right"
                      id="§RANDOM_ID§-node-image-size-factor-text"></span>
                <input class="§RANDOM_ID§-slider"
                       id="§RANDOM_ID§-node-image-size-factor-slider"
                       type="range" min="0.01" max="5.0" step="0.01">
              </div>
            </div>
          </div>
        </div>
        <!-- Menu: Node labels -->
        <div class="§RANDOM_ID§-menu-item-head"
             id="§RANDOM_ID§-node-label-head">
          Node labels
        </div>
        <div class="§RANDOM_ID§-menu-item-body"
             id="§RANDOM_ID§-node-label-body">
          <!-- Sub-menu: Visibility -->
          <div>
            <div class="§RANDOM_ID§-menu-subitem-head">
              Visibility
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <div class="§RANDOM_ID§-labeled-input">
                <input class="§RANDOM_ID§-checkbox"
                       id="§RANDOM_ID§-node-label-checkbox"
                       type="checkbox">
                <label class="§RANDOM_ID§-label"
                       for="§RANDOM_ID§-node-label-checkbox">Show node labels</label>
              </div>
              <div class="§RANDOM_ID§-labeled-input">
                <input class="§RANDOM_ID§-checkbox"
                       id="§RANDOM_ID§-node-label-border-checkbox"
                       type="checkbox">
                <label class="§RANDOM_ID§-label"
                       for="§RANDOM_ID§-node-label-border-checkbox">Show borders</label>
              </div>
            </div>
          </div>
          <!-- Sub-menu: Size -->
          <div>
            <div class="§RANDOM_ID§-menu-subitem-head">
              Size
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <span class="§RANDOM_ID§-slider-text-left">Scaling factor</span>
              <span class="§RANDOM_ID§-slider-text-right"
                    id="§RANDOM_ID§-node-label-size-factor-text"></span>
              <input class="§RANDOM_ID§-slider"
                     id="§RANDOM_ID§-node-label-size-factor-slider"
                     type="range" min="0.01" max="5.0" step="0.01">
            </div>
          </div>
          <!-- Sub-menu: Rotation -->
          <div id="§RANDOM_ID§-node-label-rotation">
            <div class="§RANDOM_ID§-menu-subitem-head">
              Rotation
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <span class="§RANDOM_ID§-slider-text-left">Angle</span>
              <span class="§RANDOM_ID§-slider-text-right"
                    id="§RANDOM_ID§-node-label-rotation-text"></span>
              <input class="§RANDOM_ID§-slider"
                     id="§RANDOM_ID§-node-label-rotation-slider"
                     type="range" min="0.0" max="359.0" step="1.0">
            </div>
          </div>
        </div>
        <!-- Menu: Edges -->
        <div class="§RANDOM_ID§-menu-item-head"
             id="§RANDOM_ID§-edge-head">
          Edges
        </div>
        <div class="§RANDOM_ID§-menu-item-body"
             id="§RANDOM_ID§-edge-body">
          <!-- Sub-menu: Visibility -->
          <div>
            <div class="§RANDOM_ID§-menu-subitem-head">
              Visibility
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <div class="§RANDOM_ID§-labeled-input">
                <input class="§RANDOM_ID§-checkbox"
                       id="§RANDOM_ID§-edge-checkbox"
                       type="checkbox">
                <label class="§RANDOM_ID§-label"
                       for="§RANDOM_ID§-edge-checkbox">Show edges</label>
              </div>
            </div>
          </div>
          <!-- Sub-menu: Size -->
          <div>
            <div class="§RANDOM_ID§-menu-subitem-head">
              Size
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <span class="§RANDOM_ID§-slider-text-left">Scaling factor</span>
              <span class="§RANDOM_ID§-slider-text-right"
                    id="§RANDOM_ID§-edge-size-factor-text"></span>
              <input class="§RANDOM_ID§-slider"
                     id="§RANDOM_ID§-edge-size-factor-slider"
                     type="range" min="0.01" max="5.0" step="0.01">
            </div>
          </div>
          <!-- Sub-menu: Form -->
          <div>
            <div class="§RANDOM_ID§-menu-subitem-head">
              Form
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <span class="§RANDOM_ID§-slider-text-left">Curvature</span>
              <span class="§RANDOM_ID§-slider-text-right"
                    id="§RANDOM_ID§-edge-curvature-text"></span>
              <input class="§RANDOM_ID§-slider"
                     id="§RANDOM_ID§-edge-curvature-slider"
                     type="range" min="-1.2" max="1.2" step="0.02">
            </div>
          </div>
          <!-- Sub-menu: Hover behavior -->
          <div>
            <div class="§RANDOM_ID§-menu-subitem-head">
              Hover behavior
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <div class="§RANDOM_ID§-labeled-input">
                <input class="§RANDOM_ID§-checkbox"
                       id="§RANDOM_ID§-edge-hover-tooltip-checkbox"
                       type="checkbox">
                <label class="§RANDOM_ID§-label"
                       for="§RANDOM_ID§-edge-hover-tooltip-checkbox">Show tooltips (if provided)</label>
              </div>
            </div>
          </div>
        </div>
        <!-- Menu: Edge labels -->
        <div class="§RANDOM_ID§-menu-item-head"
             id="§RANDOM_ID§-edge-label-head">
          Edge labels
        </div>
        <div class="§RANDOM_ID§-menu-item-body"
             id="§RANDOM_ID§-edge-label-body">
          <!-- Sub-menu: Visibility -->
          <div>
            <div class="§RANDOM_ID§-menu-subitem-head">
              Visibility
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <div class="§RANDOM_ID§-labeled-input">
                <input class="§RANDOM_ID§-checkbox"
                       id="§RANDOM_ID§-edge-label-checkbox"
                       type="checkbox">
                <label class="§RANDOM_ID§-label"
                       for="§RANDOM_ID§-edge-label-checkbox">Show edge labels</label>
              </div>
              <div class="§RANDOM_ID§-labeled-input">
                <input class="§RANDOM_ID§-checkbox"
                       id="§RANDOM_ID§-edge-label-border-checkbox"
                       type="checkbox">
                <label class="§RANDOM_ID§-label"
                       for="§RANDOM_ID§-edge-label-border-checkbox">Show borders</label>
              </div>
            </div>
          </div>
          <!-- Sub-menu: Size -->
          <div>
            <div class="§RANDOM_ID§-menu-subitem-head">
              Size
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <span class="§RANDOM_ID§-slider-text-left">Scaling factor</span>
              <span class="§RANDOM_ID§-slider-text-right"
                    id="§RANDOM_ID§-edge-label-size-factor-text"></span>
              <input class="§RANDOM_ID§-slider"
                     id="§RANDOM_ID§-edge-label-size-factor-slider"
                     type="range" min="0.01" max="5.0" step="0.01">
            </div>
          </div>
          <!-- Sub-menu: Rotation -->
          <div id="§RANDOM_ID§-edge-label-rotation">
            <div class="§RANDOM_ID§-menu-subitem-head">
              Rotation
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <span class="§RANDOM_ID§-slider-text-left">Angle</span>
              <span class="§RANDOM_ID§-slider-text-right"
                      id="§RANDOM_ID§-edge-label-rotation-text"></span>
              <input class="§RANDOM_ID§-slider"
                     id="§RANDOM_ID§-edge-label-rotation-slider"
                     type="range" min="0.0" max="359.0" step="1.0">
            </div>
          </div>
        </div>
        <!-- Menu: Layout algorithm -->
        <div class="§RANDOM_ID§-menu-item-head"
             id="§RANDOM_ID§-layout-algorithm-head">
          Layout algorithm
        </div>
        <div class="§RANDOM_ID§-menu-item-body"
             id="§RANDOM_ID§-layout-algorithm-body">
          <!-- Sub-menu: Simulation -->
          <div>
            <div class="§RANDOM_ID§-menu-subitem-head">
              Simulation
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <div class="§RANDOM_ID§-labeled-input">
                <input class="§RANDOM_ID§-checkbox"
                       id="§RANDOM_ID§-simulation-active-checkbox"
                       type="checkbox">
                <label class="§RANDOM_ID§-label"
                       for="§RANDOM_ID§-simulation-active-checkbox">Active</label>
              </div>
            </div>
          </div>
          <!-- Sub-menu: Algorithm -->
          <div>
            <div class="§RANDOM_ID§-menu-subitem-head">
              Algorithm
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <div>
                <select class="§RANDOM_ID§-select"
                        id="§RANDOM_ID§-layout-algorithm-select"></select>
              </div>
            </div>
          </div>
          <!-- Sub-menu: Parameters -->
          <div>
            <div class="§RANDOM_ID§-menu-subitem-head">
              Parameters
            </div>
            <div class="§RANDOM_ID§-menu-subitem-body">
              <div id="§RANDOM_ID§-gravitational-constant-div">
                <span class="§RANDOM_ID§-slider-text-left">Gravitational constant</span>
                <span class="§RANDOM_ID§-slider-text-right"
                      id="§RANDOM_ID§-gravitational-constant-text"></span>
                <input class="§RANDOM_ID§-slider"
                       id="§RANDOM_ID§-gravitational-constant-slider"
                       type="range" min="-50000" max="0" step="1"
                       style="direction:rtl;">
              </div>
              <div id="§RANDOM_ID§-spring-length-div">
                <span class="§RANDOM_ID§-slider-text-left">Spring length</span>
                <span class="§RANDOM_ID§-slider-text-right"
                      id="§RANDOM_ID§-spring-length-text"></span>
                <input class="§RANDOM_ID§-slider"
                       id="§RANDOM_ID§-spring-length-slider"
                       type="range" min="0.0" max="500" step="0.1">
              </div>
              <div id="§RANDOM_ID§-spring-constant-div">
                <span class="§RANDOM_ID§-slider-text-left">Spring constant</span>
                <span class="§RANDOM_ID§-slider-text-right"
                      id="§RANDOM_ID§-spring-constant-text"></span>
                <input class="§RANDOM_ID§-slider"
                       id="§RANDOM_ID§-spring-constant-slider"
                       type="range" min="0.0" max="1.0" step="0.01">
              </div>
              <div id="§RANDOM_ID§-avoid-overlap-div">
                <span class="§RANDOM_ID§-slider-text-left">Avoid overlap</span>
                <span class="§RANDOM_ID§-slider-text-right"
                      id="§RANDOM_ID§-avoid-overlap-text"></span>
                <input class="§RANDOM_ID§-slider"
                       id="§RANDOM_ID§-avoid-overlap-slider"
                       type="range" min="0.0" max="1.0" step="0.01">
              </div>
              <div id="§RANDOM_ID§-central-gravity-div">
                <span class="§RANDOM_ID§-slider-text-left">Central gravity</span>
                <span class="§RANDOM_ID§-slider-text-right"
                      id="§RANDOM_ID§-central-gravity-text"></span>
                <input class="§RANDOM_ID§-slider"
                       id="§RANDOM_ID§-central-gravity-slider"
                       type="range" min="0.0" max="10.0" step="0.001">
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script charset="utf-8" type="text/javascript">
    if(typeof(require) === "undefined"){
      §LOAD_REQUIRE§
    }
    §DEFINE_VIS§

    require(["gravis-vis-network"], function(vis){
      // Strict mode: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Strict_mode
      "use strict";

      const state = {
        manager:{
          // Data generation process: 1) Fetch state.rawData, 2) derive state.parsedData, 3) derive state.shownData

          // 1) Fetch state.rawData
          fetchRawDataFromTemplating(){
            state.rawData = §DATA§;
            // Data selection and normalization
            state.nodeSizeDataSource = §NODE_SIZE_DATA_SOURCE§;
            state.useNodeSizeNormalization = §USE_NODE_SIZE_NORMALIZATION§;
            state.nodeSizeNormalizationMin = §NODE_SIZE_NORMALIZATION_MIN§;
            state.nodeSizeNormalizationMax = §NODE_SIZE_NORMALIZATION_MAX§;
            state.nodeLabelTextDataSource = §NODE_LABEL_DATA_SOURCE§;
            state.edgeSizeDataSource = §EDGE_SIZE_DATA_SOURCE§;
            state.useEdgeSizeNormalization = §USE_EDGE_SIZE_NORMALIZATION§;
            state.edgeSizeNormalizationMin = §EDGE_SIZE_NORMALIZATION_MIN§;
            state.edgeSizeNormalizationMax = §EDGE_SIZE_NORMALIZATION_MAX§;
            state.edgeLabelTextDataSource = §EDGE_LABEL_DATA_SOURCE§;
            // Containers
            state.graphContainerHeight = §GRAPH_HEIGHT§;
            state.detailsContainerHeight = §DETAILS_HEIGHT§;
            state.showDetails = §SHOW_DETAILS§,
            state.showDetailsToggleButton = §SHOW_DETAILS_TOGGLE_BUTTON§,
            state.showMenu = §SHOW_MENU§,
            state.showMenuToggleButton = §SHOW_MENU_TOGGLE_BUTTON§,
            // Nodes
            state.showNodes = §SHOW_NODE§;
            state.nodeSizeFactor = §NODE_SIZE_FACTOR§;
            state.nodeDragFix = §NODE_DRAG_FIX§;
            state.nodeHoverNeighborhood = §NODE_HOVER_NEIGHBORHOOD§;
            state.nodeHoverTooltip = §NODE_HOVER_TOOLTIP§;
            state.showNodeImages = §SHOW_NODE_IMAGE§;
            state.nodeImageSizeFactor = §NODE_IMAGE_SIZE_FACTOR§;
            state.showNodeLabels = §SHOW_NODE_LABEL§;
            state.showNodeLabelBorders = §SHOW_NODE_LABEL_BORDER§;
            state.nodeLabelSizeFactor = §NODE_LABEL_SIZE_FACTOR§;
            state.nodeLabelRotation = §NODE_LABEL_ROTATION§;
            state.nodeLabelFont = §NODE_LABEL_FONT§;
            // Edges
            state.showEdges = §SHOW_EDGE§;
            state.edgeSizeFactor = §EDGE_SIZE_FACTOR§;
            state.edgeCurvature = §EDGE_CURVATURE§;
            state.edgeHoverTooltip = §EDGE_HOVER_TOOLTIP§,
            state.showEdgeLabels = §SHOW_EDGE_LABEL§;
            state.showEdgeLabelBorders = §SHOW_EDGE_LABEL_BORDER§;
            state.edgeLabelSizeFactor = §EDGE_LABEL_SIZE_FACTOR§;
            state.edgeLabelRotation = §EDGE_LABEL_ROTATION§;
            state.edgeLabelFont = §EDGE_LABEL_FONT§;
            // Layout algorithm
            state.layoutAlgorithmActive = §LAYOUT_ALGORITHM_ACTIVE§;
            state.layoutAlgorithm = §LAYOUT_ALGORITHM§;
            state.gravitationalConstant = §GRAVITATIONLAL_CONSTANT§;
            state.centralGravity = §CENTRAL_GRAVITY§;
            state.springLength = §SPRING_LENGTH§;
            state.springConstant = §SPRING_CONSTANT§;
            state.avoidOverlap = §AVOID_OVERLAP§;
            // Other
            state.initZoomFactor = §ZOOM_FACTOR§;
            state.largeGraphThreshold = §LARGE_GRAPH_THRESHOLD§;
          },

          // 2) Derive state.parsedData from state.givenData
          rawDataParser:{
            getBool(obj, prop, def){
              try{
                const value = obj[prop];
                if(value == "true" || value == "True"){
                  value = true;
                } else if(value == "false" || value == "False"){
                  value = false;
                }
                if(value !== true && value !== false){
                  throw "Invalid value. Not a bool.";
                }
                return value;
              } catch(e){
                return def;
              }
              return def
            },

            getString(obj, prop, def) {
              try{
                const value = String(obj[prop]);
                if(value === "undefined"){
                  throw "Invalid value. Not a proper string.";
                }
                return value;
              } catch(e){
                return def;
              }
              return def;
            },

            getArrayLengthOrZero(array){
              try{
                const value = parseInt(array.length);
                if(!((value + 1) > 0)){
                  throw "Invalid value. Not a proper length.";
                }
                return value;
              } catch(e){
                return 0;
              }
            },

            getObjectLengthOrZero(obj){
              try{
                const value = Object.keys(obj).length;
                if(!((value + 1) > 0)){
                  throw "Invalid value. Not a proper length.";
                }
                return value;
              } catch(e){
                return 0;
              }
            },

            createUniqueEdgeId(sourceId, targetId, knownEdgeIds){
              let newEdgeIdBase = "(" + sourceId + ", " + targetId + ")",
                newEdgeId = newEdgeIdBase,
                multiEdgeCounter = 1;
              for(let i=1; knownEdgeIds.has(newEdgeId); i++){
                newEdgeId = newEdgeIdBase + "_" + String(i);
                multiEdgeCounter += 1;
              }
              knownEdgeIds.add(newEdgeId);
              return {"id": newEdgeId, "count": multiEdgeCounter}
            },
          },

          rawMetadataParser:{
            getString(obj, prop, def){
              try{
                const value = String(obj.metadata[prop]);
                if(value === "undefined"){
                  throw "Invalid value. Not a proper string.";
                }
                return value;
              } catch(e){
                return def;
              }
            },
            getShape(obj, prop, def){
              const givenShape = state.manager.rawMetadataParser.getString(obj, prop, def);
              let visShape = def;
              if(givenShape === "circle"){
                visShape = "dot";
              } else if(givenShape === "rectangle"){
                visShape = "square";
              } else if(givenShape === "hexagon"){
                visShape = "hexagon";
              }
              return visShape;
            },
            getColor(obj, prop, def){
              function isBodyidColor(strColor) {
                const sty = new Option().style;
                sty.color = strColor;
                return sty.color !== "";
              }
              try{
                const value = obj.metadata[prop];
                if(!isBodyidColor(value)){
                  throw "Invalid value. Not a color."
                }
                return value;
              } catch(e){
                return def;
              }
            },
            getFiniteNumber(obj, prop, def){
              try{
                const value = parseFloat(obj.metadata[prop]);
                if(!isFinite(value) || value === null){
                  throw "Invalid value. Not a finite number."
                }
                return value;
              } catch(e){
                return def;
              }
            },
            getFiniteNumberOrNull(obj, prop, def){
              try{
                const value = parseFloat(obj.metadata[prop]);
                if(!isFinite(value)){  // Note: isFinite(null) gives true
                  throw "Invalid value. Not a finite number or null."
                }
                return value;
              } catch(e){
                return def;
              }
            },
            getFinitePositiveNumber(obj, prop, def){
              try{
                const value = parseFloat(obj.metadata[prop]);
                if(!isFinite(value) || value === null || value < 0.0){
                  throw "Invalid value. Not a finite positive number."
                }
                return value;
              } catch(e){
                return def;
              }
            },
            collectOtherMetadata(sourceObject, targetObject, definedMetadata){
              if(typeof(sourceObject) !== "undefined" && typeof(sourceObject.metadata) !== "undefined"){
                const properties = Object.keys(sourceObject.metadata);
                for(let i=0; i<properties.length; i++){
                  const property = properties[i];
                  if(!definedMetadata.has(property)){
                    targetObject[property] = sourceObject.metadata[property];
                  }
                }
              }
            },
          },

          propertyClassifier:{
            numeric: null,
            nonNumeric: null,
            init(){
              this.numeric = new Set(),
              this.nonNumeric = new Set();
            },
            isNumeric(d){
              return d === null || typeof(d) === "undefined" || String(parseFloat(d)) === String(d);
            },
            inspect(object, property){
              const value = object[property];
              if(!this.nonNumeric.has(property)){
                if(this.isNumeric(value)){
                  this.numeric.add(property);
                } else{
                  this.nonNumeric.add(property);
                  this.numeric.delete(property);
                }
              }
            }
          },

          replaceStringVariables(givenString, givenItem, variables){
            let newString = givenString;
            for(let i=0; i<variables.length; i++){
              let variable = variables[i],
                variableText = "$" + variable;
              if(variable === "x"){
                variable = "fx";
              } else if (variable === "y"){
                variable = "fy";
              }
              let insertedText = String(givenItem[variable]);
              if(insertedText === "undefined"){
                insertedText = "";
              }
              newString = newString.replace(variableText, insertedText);
            }
            return newString;
          },

          parseGeneral(givenData, parsedData){
            parsedData.general = {
              // General
              directed: state.manager.rawDataParser.getBool(givenData, "directed", true),
              label: state.manager.rawDataParser.getString(givenData, "label", ""),
              background_color: state.manager.rawMetadataParser.getColor(givenData, "background_color", "white"),
              arrow_color: state.manager.rawMetadataParser.getColor(givenData, "arrow_color", "black"),
              arrow_size: state.manager.rawMetadataParser.getFinitePositiveNumber(givenData, "arrow_size", 10.0),
              // Nodes
              node_color: state.manager.rawMetadataParser.getColor(givenData, "node_color", "black"),
              node_opacity: state.manager.rawMetadataParser.getFinitePositiveNumber(givenData, "node_opacity", 1.0),
              node_size: state.manager.rawMetadataParser.getFinitePositiveNumber(givenData, "node_size", 10.0),
              node_shape: state.manager.rawMetadataParser.getString(givenData, "node_shape", "circle"),
              node_border_color: state.manager.rawMetadataParser.getColor(givenData, "node_border_color", "black"),
              node_border_size: state.manager.rawMetadataParser.getFinitePositiveNumber(givenData, "node_border_size", 0.0),
              node_label_color: state.manager.rawMetadataParser.getColor(givenData, "node_label_color", "black"),
              node_label_size: state.manager.rawMetadataParser.getFinitePositiveNumber(givenData, "node_label_size", 12.0),
              node_hover: state.manager.rawMetadataParser.getString(givenData, "node_hover", ""),
              node_click: state.manager.rawMetadataParser.getString(givenData, "node_click", ""),
              node_image: state.manager.rawMetadataParser.getString(givenData, "node_image", ""),
              node_x: state.manager.rawMetadataParser.getFiniteNumberOrNull(givenData, "node_x", null),
              node_y: state.manager.rawMetadataParser.getFiniteNumberOrNull(givenData, "node_y", null),
              contains_node_hover: false,
              contains_node_click: false,
              contains_node_image: false,
              // Edges
              edge_color: state.manager.rawMetadataParser.getColor(givenData, "edge_color", "black"),
              edge_opacity: state.manager.rawMetadataParser.getFinitePositiveNumber(givenData, "edge_opacity", 1.0),
              edge_size: state.manager.rawMetadataParser.getFinitePositiveNumber(givenData, "edge_size", 1.0),
              edge_label_color: state.manager.rawMetadataParser.getColor(givenData, "edge_label_color", "black"),
              edge_label_size: state.manager.rawMetadataParser.getFinitePositiveNumber(givenData, "edge_label_size", 8.0),
              edge_hover: state.manager.rawMetadataParser.getString(givenData, "edge_hover", ""),
              edge_click: state.manager.rawMetadataParser.getString(givenData, "edge_click", ""),
              contains_edge_hover: false,
              contains_edge_click: false,
            };
            if(!parsedData.general.directed){
              parsedData.general.arrow_size = 0.0;
            }
          },

          parseNodes(givenData, parsedData){
            const numNodes = state.manager.rawDataParser.getObjectLengthOrZero(givenData.nodes),
              nodeIdToObjectMap = new Map(),
              nodeDefinedMetadata = new Set(
                ["color", "opacity", "size", "shape", "border_color", "border_size",
                 "label_color", "label_size", "hover", "click", "image", "x", "y"]),
              nodeReplacementVariables = [
                "id", "label",
                "color", "opacity", "size", "shape", "border_color", "border_size",
                "label_color", "label_size", "image", "x", "y"];
            state.manager.propertyClassifier.init();
            try {
              Object.entries(givenData.nodes);
            }
            catch(e){
               givenData.nodes = {};
            }
            for (const [givenNodeId, givenNode] of Object.entries(givenData.nodes)) {
              const parsedNode = {};
              // data: id, label
              parsedNode.id = String(givenNodeId);
              parsedNode.label = state.manager.rawDataParser.getString(givenNode, "label", "");
              // defined metadata
              parsedNode.color = state.manager.rawMetadataParser.getColor(givenNode, "color", parsedData.general.node_color);
              parsedNode.opacity = state.manager.rawMetadataParser.getFinitePositiveNumber(givenNode, "opacity", parsedData.general.node_opacity);
              parsedNode.size = state.manager.rawMetadataParser.getFinitePositiveNumber(givenNode, "size", parsedData.general.node_size);
              parsedNode.shape = state.manager.rawMetadataParser.getShape(givenNode, "shape", parsedData.general.node_shape);
              parsedNode.border_color = state.manager.rawMetadataParser.getColor(givenNode, "border_color", parsedData.general.node_border_color);
              parsedNode.border_size = state.manager.rawMetadataParser.getFinitePositiveNumber(givenNode, "border_size", parsedData.general.node_border_size);
              parsedNode.label_color = state.manager.rawMetadataParser.getColor(givenNode, "label_color", parsedData.general.node_label_color);
              parsedNode.label_size = state.manager.rawMetadataParser.getFinitePositiveNumber(givenNode, "label_size", parsedData.general.node_label_size);
              const hover = state.manager.rawMetadataParser.getString(givenNode, "hover", parsedData.general.node_hover);
              const image = state.manager.rawMetadataParser.getString(givenNode, "image", parsedData.general.node_image);
              if(image !== ""){
                parsedNode.image = image;
                parsedData.general.contains_node_image = true;
              }
              if(hover !== ""){
                parsedNode.hover = hover;
                parsedData.general.contains_node_hover = true;
              }
              const click = state.manager.rawMetadataParser.getString(givenNode, "click", parsedData.general.node_click);
              if(click !== ""){
                parsedNode.click = click;
                parsedData.general.contains_node_click = true;
              }
              const x = state.manager.rawMetadataParser.getFiniteNumberOrNull(givenNode, "x", parsedData.general.node_x);
              const y = state.manager.rawMetadataParser.getFiniteNumberOrNull(givenNode, "y", parsedData.general.node_y);
              if(x !== null){
                parsedNode.fx = x;
              }
              if(y !== null){
                parsedNode.fy = y;
              }
              // other metadata
              const otherMetadata = state.manager.rawMetadataParser.collectOtherMetadata(givenNode, parsedNode, nodeDefinedMetadata);
              // feature classification
              const parsedNodeProperties = Object.keys(parsedNode);
              for(let i=0; i<parsedNodeProperties.length; i++){
                const property = parsedNodeProperties[i],
                  value = parsedNode[property];
                state.manager.propertyClassifier.inspect(parsedNode, property);
              }
              // variable replacements
              if(parsedNode.hover){
                parsedNode.hover = state.manager.replaceStringVariables(parsedNode.hover, parsedNode, nodeReplacementVariables);
              }
              if(parsedNode.click){
                parsedNode.click = state.manager.replaceStringVariables(parsedNode.click, parsedNode, nodeReplacementVariables.concat(["hover"]));
              }
              // store the parsed node
              parsedData.nodes.push(parsedNode);
              // data structure for inserting node object references into edge data
              nodeIdToObjectMap.set(parsedNode.id, parsedNode);
            }
            // Ensure numeric properties (except fx and fy) are stored as numbers and remember their extrema
            const numericProperties = Array.from(state.manager.propertyClassifier.numeric).filter(name => name !== "fx" && name !== "fy"),
              nonNumericProperties = Array.from(state.manager.propertyClassifier.nonNumeric),
              minima = {},
              maxima = {};
            for(let i=0; i<numNodes; i++){
              const parsedNode = parsedData.nodes[i];
              for(let p=0; p<numericProperties.length; p++){
                const property = numericProperties[p],
                  numericValue = parseFloat(parsedNode[property]);
                parsedNode[property] = numericValue;
                if(isFinite(numericValue)){
                  if(typeof(minima[property]) === "undefined" || numericValue < minima[property]){
                    minima[property] = numericValue;
                  }
                  if(typeof(maxima[property]) === "undefined" || numericValue > maxima[property]){
                    maxima[property] = numericValue;
                  }
                }
              }
            }
            // Store feature classification and extrema
            parsedData.general.node_properties = {
              "node_size_data_sources": numericProperties,
              "node_label_text_data_sources": nonNumericProperties.concat(numericProperties),
              "minima": minima,
              "maxima": maxima,
            }
            // Report empty graph
            if(!(numNodes > 0)){
              console.log("Caution: Graph with 0 nodes. The provided data might be in the wrong format.");
            }
            return nodeIdToObjectMap;
          },

          parseEdges(givenData, parsedData, nodeIdToObjectMap){
            let numEdges = state.manager.rawDataParser.getArrayLengthOrZero(givenData.edges);
            const knownEdgeIds = new Set(),
              ignoredEdges = [],
              edgeDefinedMetadata = new Set(
                ["color", "opacity", "size", "label_color", "label_size", "hover", "click"]),
              edgeReplacementVariables = [
                "id", "label",
                "color", "opacity", "size", "label_color", "label_size"];
            state.manager.propertyClassifier.init();
            for(let i=0; i<numEdges; i++){
              const givenEdge = givenData.edges[i],
                parsedEdge = {},
                sourceId = String(givenEdge.source),
                targetId = String(givenEdge.target);
              // data: source, target, id, multi_edge_counter, label
              try{
                const sourceObj = nodeIdToObjectMap.get(sourceId);
                const targetObj = nodeIdToObjectMap.get(targetId);
                if(typeof(sourceObj) === "undefined" || typeof(targetObj) === "undefined"){
                  throw "Invalid node reference.";
                }
                parsedEdge.source = sourceObj;
                parsedEdge.target = targetObj;
              } catch(e){
                const ignoredEdge = {
                  index: i,
                  source: sourceId,
                  target: targetId,
                }
                ignoredEdges.push(ignoredEdge);
                continue;
              }
              const result = state.manager.rawDataParser.createUniqueEdgeId(sourceId, targetId, knownEdgeIds);
              parsedEdge.id = result.id;
              parsedEdge.multi_edge_counter = result.count;
              parsedEdge.label = state.manager.rawDataParser.getString(givenEdge, "label", "");
              // defined metadata
              parsedEdge.color = state.manager.rawMetadataParser.getColor(givenEdge, "color", parsedData.general.edge_color);
              parsedEdge.opacity = state.manager.rawMetadataParser.getFinitePositiveNumber(givenEdge, "opacity", parsedData.general.edge_opacity);
              parsedEdge.size = state.manager.rawMetadataParser.getFinitePositiveNumber(givenEdge, "size", parsedData.general.edge_size);
              parsedEdge.label_color = state.manager.rawMetadataParser.getColor(givenEdge, "label_color", parsedData.general.edge_label_color);
              parsedEdge.label_size = state.manager.rawMetadataParser.getFinitePositiveNumber(givenEdge, "label_size", parsedData.general.edge_label_size);
              const hover = state.manager.rawMetadataParser.getString(givenEdge, "hover", parsedData.general.edge_hover);
              if(hover !== ""){
                parsedEdge.hover = hover;
                parsedData.general.contains_edge_hover = true;
              }
              const click = state.manager.rawMetadataParser.getString(givenEdge, "click", parsedData.general.edge_click);
              if(click !== ""){
                parsedEdge.click = click;
                parsedData.general.contains_edge_click = true;
              }
              // other metadata
              const otherMetadata = state.manager.rawMetadataParser.collectOtherMetadata(givenEdge, parsedEdge, edgeDefinedMetadata);
              // feature classification
              const parsedEdgeProperties = Object.keys(parsedEdge);
              for(let i=0; i<parsedEdgeProperties.length; i++){
                const property = parsedEdgeProperties[i],
                  value = parsedEdge[property];
                state.manager.propertyClassifier.inspect(parsedEdge, property);
              }
              // variable replacements
              if(parsedEdge.hover){
                parsedEdge.hover = state.manager.replaceStringVariables(parsedEdge.hover, parsedEdge, edgeReplacementVariables);
              }
              if(parsedEdge.click){
                parsedEdge.click = state.manager.replaceStringVariables(parsedEdge.click, parsedEdge, edgeReplacementVariables.concat(["hover"]));
              }
              // store it
              parsedData.edges.push(parsedEdge);
            }
            // Ensure numeric properties are stored as numbers and remember their extrema
            const numericProperties = Array.from(state.manager.propertyClassifier.numeric),
              nonNumericProperties = Array.from(state.manager.propertyClassifier.nonNumeric),
              minima = {},
              maxima = {};
            numEdges = state.manager.rawDataParser.getArrayLengthOrZero(parsedData.edges);
            for(let i=0; i<numEdges; i++){
              const parsedEdge = parsedData.edges[i];
              for(let p=0; p<numericProperties.length; p++){
                const property = numericProperties[p],
                  numericValue = parseFloat(parsedEdge[property]);
                parsedEdge[property] = numericValue;
                if(isFinite(numericValue)){
                  if(typeof(minima[property]) === "undefined" || numericValue < minima[property]){
                    minima[property] = numericValue;
                  }
                  if(typeof(maxima[property]) === "undefined" || numericValue > maxima[property]){
                    maxima[property] = numericValue;
                  }
                }
              }
            }
            // Store feature classification and extrema
            parsedData.general.edge_properties = {
              "edge_size_data_sources": numericProperties.filter(item => item !== "multi_edge_counter"),
              "edge_label_text_data_sources": nonNumericProperties.concat(numericProperties).filter(
                item => item !== "source" && item !== "target" && item !== "multi_edge_counter"),
              "minima": minima,
              "maxima": maxima,
            }
            // Report invalid edges
            if(ignoredEdges.length > 0){
              let message = undefined;
              if(ignoredEdges.length == 1){
                message = "Caution: " + ignoredEdges.length + " edge was ignored because it " +
                  "refers to a node that is not part of the node list:\n";
              } else{
                message = "Caution: " + ignoredEdges.length + " edges were ignored because they " +
                  "refer to a node that is not part of the node list:\n";
              }
              for(let i=0; i<ignoredEdges.length; i++){
                const ignoredEdge = ignoredEdges[i];
                message += '- Edge with index ' + ignoredEdge.index;
                message += ', source "' + ignoredEdge.source;
                message += '", target "' + ignoredEdge.target + '"\n';
                if(i==9){
                  message += '...';
                  break;
                }
              }
              console.log(message);
            }
          },

          parseChosenData(chosenGraphNumber){
            let givenData = state.rawData[chosenGraphNumber],
              parsedData = {
                general: {},
                nodes: [],
                edges: [],
                adjacency: null,
                incidence: null,
              };
            if(!givenData || givenData === null){
              givenData = [];
            }
            // a) General
            state.manager.parseGeneral(givenData, parsedData);
            // b) Nodes
            const nodeIdToObjectMap = state.manager.parseNodes(givenData, parsedData);
            // c) Edges
            state.manager.parseEdges(givenData, parsedData, nodeIdToObjectMap);
            // Update state
            state.parsedData = parsedData;
            state.currentGraphParts = {};
            // Update UI: show or hide containers
            ui.elements.graphContainer.style.display = ui.convert.boolToDisplayStyle(true);
            ui.elements.detailsContainer.style.display = ui.convert.boolToDisplayStyle(state.showDetails);
            ui.elements.nodeImageMetaControl.style.display = ui.convert.boolToDisplayStyle(parsedData.general.contains_node_image);
          },

          // 3) Derive state.shownData from state.parsedData
          createNodeToAdjacentNodesMap(){
            const dataStructure = {
              map: new Map(),
              add(sourceNode, targetNode){
                let adjacentNodes = this.map.get(sourceNode);
                if(adjacentNodes){
                  adjacentNodes.add(targetNode);
                } else{
                  adjacentNodes = new Set([targetNode]);
                  this.map.set(sourceNode, adjacentNodes);
                }
              },
            }
            return dataStructure;
          },

          createNodeToIncidentEdgesMap(){
            const dataStructure = {
              map: new Map(),
              add(node, edge){
                let incidentEdges = this.map.get(node);
                if(incidentEdges){
                  incidentEdges.add(edge);
                } else{
                  incidentEdges = new Set([edge]);
                  this.map.set(node, incidentEdges);
                }
              },
            }
            return dataStructure;
          },

          hoverTextToHtml(text) {
            // https://visjs.github.io/vis-network/examples/network/other/html-in-titles.html
            const div = document.createElement("div");
            div.innerHTML = text;
            return div;
          },

          prepareShownData(){
            const numNodes = state.parsedData.nodes.length,
              numEdges = state.parsedData.edges.length;
            state.shownData = {
              "general": null,
              "nodes": new Array(numNodes),
              "edges": new Array(numEdges),
            }
            const nodeIdToObjectMap = new Map(),
              nodeSizeNormalizer = state.manager.createNodeSizeNormalizer();
            // a) General
            state.shownData.general = {
              "background_color": state.parsedData.general.background_color,
              "arrow_size": state.parsedData.general.arrow_size,
              "arrow_color": state.parsedData.general.arrow_color,
              "directed": state.parsedData.general.directed,
            };
            // b) Nodes
            for(let i=0; i<numNodes; i++){
              state.shownData.nodes[i] = {};
              const parsedNode = state.parsedData.nodes[i],
                shownNode = state.shownData.nodes[i];
              shownNode.id = parsedNode.id;
              shownNode.label = state.manager.calcSingleNodeLabelText(parsedNode);
              shownNode.color = parsedNode.color;
              shownNode.opacity = parsedNode.opacity;
              shownNode.size = state.manager.calcSingleNodeSize(parsedNode, nodeSizeNormalizer);
              shownNode.shape = parsedNode.shape;
              shownNode.border_color = parsedNode.border_color;
              shownNode.border_size = parsedNode.border_size;
              shownNode.label_color = parsedNode.label_color;
              shownNode.label_size = state.manager.calcSingleNodeLabelSize(parsedNode);
              if(typeof(parsedNode.image) !== "undefined"){
                shownNode.image = parsedNode.image;
              }
              if(typeof(parsedNode.hover) !== "undefined"){
                shownNode.hover = state.manager.hoverTextToHtml(parsedNode.hover);
              }
              if(typeof(parsedNode.click) !== "undefined"){
                shownNode.click = parsedNode.click;
              }
              if(typeof(parsedNode.fx) !== "undefined"){
                shownNode.fx = parsedNode.fx;
              }
              if(typeof(parsedNode.fy) !== "undefined"){
                shownNode.fy = parsedNode.fy;
              }
              nodeIdToObjectMap.set(shownNode.id, shownNode);
              // Derived properties for performance improvement in updateNodePositions
              state.manager.calcSingleNodeSizeDerivatives(shownNode);
              state.manager.calcSingleNodeBorderSizeDerivatives(shownNode);
            }
            // c) Edges
            const edgeSizeNormalizer = state.manager.createEdgeSizeNormalizer(),
              nodeToAdjacentNodesMap = state.manager.createNodeToAdjacentNodesMap(),
              nodeToIncidentEdgesMap = state.manager.createNodeToIncidentEdgesMap();
            for(let i=0; i<numEdges; i++){
              state.shownData.edges[i] = {};
              const parsedEdge = state.parsedData.edges[i],
                shownEdge = state.shownData.edges[i];
              shownEdge.source = nodeIdToObjectMap.get(parsedEdge.source.id);
              shownEdge.target = nodeIdToObjectMap.get(parsedEdge.target.id);
              shownEdge.id = parsedEdge.id;
              shownEdge.label = state.manager.calcSingleEdgeLabelText(parsedEdge);
              shownEdge.color = parsedEdge.color;
              shownEdge.opacity = parsedEdge.opacity;
              shownEdge.size = state.manager.calcSingleEdgeSize(parsedEdge, edgeSizeNormalizer);
              shownEdge.label_color = parsedEdge.label_color;
              shownEdge.label_size = state.manager.calcSingleEdgeLabelSize(parsedEdge);
              if(typeof(parsedEdge.hover) !== "undefined"){
                shownEdge.hover = state.manager.hoverTextToHtml(parsedEdge.hover);
              }
              if(typeof(parsedEdge.click) !== "undefined"){
                shownEdge.click = parsedEdge.click;
              }
              // Derived properties for performance improvement in updateEdgePositions
              shownEdge.multiEdgeCurvatureFactor = state.manager.calcSingleEdgeCurvatureFactor(parsedEdge);
              // Data structure for highlighting adjacent nodes and incident edges to this node
              nodeToAdjacentNodesMap.add(shownEdge.source, shownEdge.target);
              nodeToAdjacentNodesMap.add(shownEdge.target, shownEdge.source);
              nodeToIncidentEdgesMap.add(shownEdge.source, shownEdge);
              nodeToIncidentEdgesMap.add(shownEdge.target, shownEdge);
            }
            state.shownData.adjacency = nodeToAdjacentNodesMap;
            state.shownData.incidence = nodeToIncidentEdgesMap;
          },

          calcSingleNodeSize(parsedNode, nodeSizeNormalizer){
            const appearanceAdaptionFactor = 0.5;
            let nodeSize = nodeSizeNormalizer(parsedNode[state.nodeSizeDataSource]);
            if(!isFinite(nodeSize)){
              nodeSize = state.parsedData.general.node_size;
            }
            return nodeSize * state.nodeSizeFactor * appearanceAdaptionFactor;
          },

          calcSingleNodeSizeDerivatives(shownNode){
            shownNode.image_size = shownNode.size / 1.42 * state.nodeImageSizeFactor;
          },

          calcSingleNodeLabelText(parsedNode){
            return String(parsedNode[state.nodeLabelTextDataSource]);
          },

          calcSingleNodeLabelSize(parsedNode){
            return parsedNode.label_size * state.nodeLabelSizeFactor;
          },

          calcSingleEdgeSize(parsedEdge, edgeSizeNormalizer){
            let edgeSize = edgeSizeNormalizer(parsedEdge[state.edgeSizeDataSource]);
            if(!isFinite(edgeSize)){
              edgeSize = state.parsedData.general.edge_size;
            }
            return edgeSize * state.edgeSizeFactor;
          },

          calcSingleEdgeCurvatureFactor(parsedEdge){
            // Caution: Currently a single value is used for all edges instead of these here
            const appearanceAdaptionFactor = 0.5;
            return state.edgeCurvature * parsedEdge.multiEdgeCounter * appearanceAdaptionFactor;
          },

          calcSingleEdgeLabelText(parsedEdge){
            return String(parsedEdge[state.edgeLabelTextDataSource]);
          },

          calcSingleEdgeLabelSize(parsedEdge){
            return parsedEdge.label_size * state.edgeLabelSizeFactor;
          },

          calcSingleNodeBorderSizeDerivatives(shownNode){
            shownNode.border_size_half = shownNode.border_size / 2.0;
          },

          createNodeSizeNormalizer(){
            let normalizer;
            if(state.useNodeSizeNormalization){
              const dataMin = state.parsedData.general.node_properties.minima[state.nodeSizeDataSource],
                dataMax = state.parsedData.general.node_properties.maxima[state.nodeSizeDataSource],
                targetMin = state.nodeSizeNormalizationMin,
                targetMax = state.nodeSizeNormalizationMax,
                dataDiff = dataMax - dataMin,
                targetDiff = targetMax - targetMin;
              let factor = targetDiff / dataDiff;
              if(!isFinite(factor) || factor === null){
                factor = 0.0;
              }
              normalizer = function(val){
                return (val - dataMin) * factor + targetMin;
              }
            } else{
              normalizer = function(val){
                return val;
              }
            }
            return normalizer;
          },

          createEdgeSizeNormalizer(){
            let normalizer;
            if(state.useEdgeSizeNormalization){
              const dataMin = state.parsedData.general.edge_properties.minima[state.edgeSizeDataSource],
                dataMax = state.parsedData.general.edge_properties.maxima[state.edgeSizeDataSource],
                targetMin = state.edgeSizeNormalizationMin,
                targetMax = state.edgeSizeNormalizationMax,
                dataDiff = dataMax - dataMin,
                targetDiff = targetMax - targetMin;
              let factor = targetDiff / dataDiff;
              if(!isFinite(factor)){
                factor = 0.0;
              }
              normalizer = function(val){
                return (val - dataMin) * factor + targetMin;
              }
            } else{
              normalizer = function(val){
                return val;
              }
            }
            return normalizer;
          },

          updateNodeSizes(){
            // Data
            const nodeSizeNormalizer = state.manager.createNodeSizeNormalizer();
            for(let i=0; i<state.parsedData.nodes.length; i++){
              const parsedNode = state.parsedData.nodes[i],
                shownNode = state.shownData.nodes[i];
              shownNode.size = state.manager.calcSingleNodeSize(parsedNode, nodeSizeNormalizer);
              state.manager.calcSingleNodeSizeDerivatives(shownNode);
            }
            // UI
            ui.composites.graph.updateNodeSizes();
          },

          updateNodeLabelTexts(){
            // Data
            for(let i=0; i<state.parsedData.nodes.length; i++){
              const parsedNode = state.parsedData.nodes[i],
                shownNode = state.shownData.nodes[i];
              shownNode.label = state.manager.calcSingleNodeLabelText(parsedNode);
            }
            // UI
            ui.composites.graph.updateNodeLabels();
          },

          updateNodeLabelSizes(){
            // Data
            for(let i=0; i<state.parsedData.nodes.length; i++){
              const parsedNode = state.parsedData.nodes[i],
                shownNode = state.shownData.nodes[i];
              shownNode.label_size = state.manager.calcSingleNodeLabelSize(parsedNode);
            }
            // UI
            ui.composites.graph.updateNodeLabels();
          },

          updateNodeImages(){
            // Data
            for(let i=0; i<state.parsedData.nodes.length; i++){
              const parsedNode = state.parsedData.nodes[i],
                shownNode = state.shownData.nodes[i];
              state.manager.calcSingleNodeSizeDerivatives(shownNode);
            }
            // UI
            ui.composites.graph.updateNodeImages();
          },

          updateEdgeSizes(){
            // Data
            const edgeSizeNormalizer = state.manager.createEdgeSizeNormalizer();
            for(let i=0; i<state.parsedData.edges.length; i++){
              const parsedEdge = state.parsedData.edges[i],
                shownEdge = state.shownData.edges[i];
              shownEdge.size = state.manager.calcSingleEdgeSize(parsedEdge, edgeSizeNormalizer);
            }
            // UI
            ui.composites.graph.updateEdgeSizes();
          },

          updateEdgeCurvatures(){
            // Data
            for(let i=0; i<state.parsedData.edges.length; i++){
              const parsedEdge = state.parsedData.edges[i],
                shownEdge = state.shownData.edges[i];
              shownEdge.multiEdgeCurvatureFactor = state.manager.calcSingleEdgeCurvatureFactor(parsedEdge);
            }
            // UI
            ui.composites.graph.updateEdgeCurvatures();
          },

          updateEdgeLabelTexts(){
            // Data
            for(let i=0; i<state.parsedData.edges.length; i++){
              const parsedEdge = state.parsedData.edges[i],
                shownEdge = state.shownData.edges[i];
              shownEdge.label = state.manager.calcSingleEdgeLabelText(parsedEdge);
            }
            // UI
            ui.composites.graph.updateEdgeLabels();
          },

          updateEdgeLabelSizes(){
            // Data
            for(let i=0; i<state.parsedData.edges.length; i++){
              const parsedEdge = state.parsedData.edges[i],
                shownEdge = state.shownData.edges[i];
              shownEdge.label_size = state.manager.calcSingleEdgeLabelSize(parsedEdge);
            }
            // UI
            ui.composites.graph.updateEdgeLabels();
          },
        }
      }

      const ui = {
        symbols:{
          // Choice of symbols is influenced by their appearance in different browsers
          // Alternatives: "▼", "▽", "▾" / "▲", "△", "▴" / "▶", "▷", "▸" / "◀", "◁", "◂"
          // ▶ is rendered strangely on some mobile phone browsers, ▸ remains normal
          detailsShown: "▾",
          detailsHidden: "▴",
          menuShown: "▸",
          menuHidden: "◂",
          menuItemActive: "▸",
          menuItemInactive: "▾",
        },

        elements:{
          // Containers
          mainContainer: document.getElementById("§RANDOM_ID§-main-div"),
          tooltipContainer: document.getElementById("§RANDOM_ID§-tooltip-div"),
          leftContainer: document.getElementById("§RANDOM_ID§-left-div"),
          rightContainer: document.getElementById("§RANDOM_ID§-right-div"),
          graphContainer: document.getElementById("§RANDOM_ID§-graph-div"),
          detailsContainer: document.getElementById("§RANDOM_ID§-details-div"),
          detailsHead: document.getElementById("§RANDOM_ID§-details-head"),
          detailsBody: document.getElementById("§RANDOM_ID§-details-body"),
          // Data sources
          dataHead: document.getElementById("§RANDOM_ID§-data-head"),
          dataBody: document.getElementById("§RANDOM_ID§-data-body"),
          graphSelectionContainer: document.getElementById("§RANDOM_ID§-graph-select-div"),
          graphSelection: document.getElementById("§RANDOM_ID§-graph-select"),
          nodeSizeDataSourceSelect: document.getElementById("§RANDOM_ID§-node-size-data-source-select"),
          nodeSizeNormalizationCheckbox: document.getElementById("§RANDOM_ID§-node-size-normalization-checkbox"),
          nodeSizeNormalizationContainer: document.getElementById("§RANDOM_ID§-node-size-norm-div"),
          nodeSizeNormalizationMinText: document.getElementById("§RANDOM_ID§-node-size-normalization-min-text"),
          nodeSizeNormalizationMinSlider: document.getElementById("§RANDOM_ID§-node-size-normalization-min-slider"),
          nodeSizeNormalizationMaxText: document.getElementById("§RANDOM_ID§-node-size-normalization-max-text"),
          nodeSizeNormalizationMaxSlider: document.getElementById("§RANDOM_ID§-node-size-normalization-max-slider"),
          edgeSizeDataSourceSelect: document.getElementById("§RANDOM_ID§-edge-size-data-source-select"),
          edgeSizeNormalizationCheckbox: document.getElementById("§RANDOM_ID§-edge-size-normalization-checkbox"),
          edgeSizeNormalizationContainer: document.getElementById("§RANDOM_ID§-edge-size-norm-div"),
          edgeSizeNormalizationMinText: document.getElementById("§RANDOM_ID§-edge-size-normalization-min-text"),
          edgeSizeNormalizationMinSlider: document.getElementById("§RANDOM_ID§-edge-size-normalization-min-slider"),
          edgeSizeNormalizationMaxText: document.getElementById("§RANDOM_ID§-edge-size-normalization-max-text"),
          edgeSizeNormalizationMaxSlider: document.getElementById("§RANDOM_ID§-edge-size-normalization-max-slider"),
          // General
          generalHead: document.getElementById("§RANDOM_ID§-general-head"),
          generalBody: document.getElementById("§RANDOM_ID§-general-body"),
          resetButton: document.getElementById("§RANDOM_ID§-reset"),
          fullscreenButton: document.getElementById("§RANDOM_ID§-fullscreen-button"),
          svgExportButton: document.getElementById("§RANDOM_ID§-svg"),
          pngExportButton: document.getElementById("§RANDOM_ID§-png"),
          jpgExportButton: document.getElementById("§RANDOM_ID§-jpg"),
          // Nodes
          nodeHead: document.getElementById("§RANDOM_ID§-node-head"),
          nodeBody: document.getElementById("§RANDOM_ID§-node-body"),
          nodeCheckbox: document.getElementById("§RANDOM_ID§-node-checkbox"),
          nodeSizeFactorText: document.getElementById("§RANDOM_ID§-node-size-factor-text"),
          nodeSizeFactorSlider: document.getElementById("§RANDOM_ID§-node-size-factor-slider"),
          nodeDragFixCheckbox: document.getElementById("§RANDOM_ID§-node-drag-fix-checkbox"),
          nodeHoverNeighborhoodCheckbox: document.getElementById("§RANDOM_ID§-node-hover-neighborhood-checkbox"),
          nodeHoverTooltipCheckbox: document.getElementById("§RANDOM_ID§-node-hover-tooltip-checkbox"),
          nodeReleaseButton: document.getElementById("§RANDOM_ID§-node-release-button"),
          // Node images
          nodeImageHead: document.getElementById("§RANDOM_ID§-node-image-head"),
          nodeImageBody: document.getElementById("§RANDOM_ID§-node-image-body"),
          nodeImageCheckbox: document.getElementById("§RANDOM_ID§-node-image-checkbox"),
          nodeImageMetaControl: document.getElementById("§RANDOM_ID§-node-image-meta-control"),
          nodeImageSizeFactorText: document.getElementById("§RANDOM_ID§-node-image-size-factor-text"),
          nodeImageSizeFactorSlider: document.getElementById("§RANDOM_ID§-node-image-size-factor-slider"),
          // Node labels
          nodeLabelHead: document.getElementById("§RANDOM_ID§-node-label-head"),
          nodeLabelBody: document.getElementById("§RANDOM_ID§-node-label-body"),
          nodeLabelCheckbox: document.getElementById("§RANDOM_ID§-node-label-checkbox"),
          nodeLabelBorderCheckbox: document.getElementById("§RANDOM_ID§-node-label-border-checkbox"),
          nodeLabelTextDataSourceSelect: document.getElementById("§RANDOM_ID§-node-label-data-source-select"),
          nodeLabelSizeFactorText: document.getElementById("§RANDOM_ID§-node-label-size-factor-text"),
          nodeLabelSizeFactorSlider: document.getElementById("§RANDOM_ID§-node-label-size-factor-slider"),
          nodeLabelRotationText: document.getElementById("§RANDOM_ID§-node-label-rotation-text"),
          nodeLabelRotationSlider: document.getElementById("§RANDOM_ID§-node-label-rotation-slider"),
          // Edges
          edgeHead: document.getElementById("§RANDOM_ID§-edge-head"),
          edgeBody: document.getElementById("§RANDOM_ID§-edge-body"),
          edgeCheckbox: document.getElementById("§RANDOM_ID§-edge-checkbox"),
          edgeSizeFactorText: document.getElementById("§RANDOM_ID§-edge-size-factor-text"),
          edgeSizeFactorSlider: document.getElementById("§RANDOM_ID§-edge-size-factor-slider"),
          edgeCurvatureText: document.getElementById("§RANDOM_ID§-edge-curvature-text"),
          edgeCurvatureSlider: document.getElementById("§RANDOM_ID§-edge-curvature-slider"),
          edgeHoverTooltipCheckbox: document.getElementById("§RANDOM_ID§-edge-hover-tooltip-checkbox"),
          // Edge labels
          edgeLabelHead: document.getElementById("§RANDOM_ID§-edge-label-head"),
          edgeLabelBody: document.getElementById("§RANDOM_ID§-edge-label-body"),
          edgeLabelCheckbox: document.getElementById("§RANDOM_ID§-edge-label-checkbox"),
          edgeLabelBorderCheckbox: document.getElementById("§RANDOM_ID§-edge-label-border-checkbox"),
          edgeLabelTextDataSourceSelect: document.getElementById("§RANDOM_ID§-edge-label-data-source-select"),
          edgeLabelSizeFactorText: document.getElementById("§RANDOM_ID§-edge-label-size-factor-text"),
          edgeLabelSizeFactorSlider: document.getElementById("§RANDOM_ID§-edge-label-size-factor-slider"),
          edgeLabelRotationText: document.getElementById("§RANDOM_ID§-edge-label-rotation-text"),
          edgeLabelRotationSlider: document.getElementById("§RANDOM_ID§-edge-label-rotation-slider"),
          // Layout algorithm
          layoutAlgorithmHead: document.getElementById("§RANDOM_ID§-layout-algorithm-head"),
          layoutAlgorithmBody: document.getElementById("§RANDOM_ID§-layout-algorithm-body"),
          simulationCheckbox: document.getElementById("§RANDOM_ID§-simulation-active-checkbox"),
          layoutAlgorithmSelection: document.getElementById("§RANDOM_ID§-layout-algorithm-select"),
          centralGravitySlider: document.getElementById("§RANDOM_ID§-central-gravity-slider"),
          centralGravityText: document.getElementById("§RANDOM_ID§-central-gravity-text"),
          springLengthSlider: document.getElementById("§RANDOM_ID§-spring-length-slider"),
          springLengthText: document.getElementById("§RANDOM_ID§-spring-length-text"),
          springConstantSlider: document.getElementById("§RANDOM_ID§-spring-constant-slider"),
          springConstantText: document.getElementById("§RANDOM_ID§-spring-constant-text"),
          gravitationalConstantContainer: document.getElementById("§RANDOM_ID§-gravitational-constant-div"),
          gravitationalConstantSlider: document.getElementById("§RANDOM_ID§-gravitational-constant-slider"),
          gravitationalConstantText: document.getElementById("§RANDOM_ID§-gravitational-constant-text"),
          avoidOverlapContainer: document.getElementById("§RANDOM_ID§-avoid-overlap-div"),
          avoidOverlapSlider: document.getElementById("§RANDOM_ID§-avoid-overlap-slider"),
          avoidOverlapText: document.getElementById("§RANDOM_ID§-avoid-overlap-text"),
        },

        composites:{
          responsiveContainer:{
            init(){
              // Delete all contained items (relevant only for reset, not first creation)
              ui.deleteChildElements(ui.elements.graphContainer);
              ui.deleteChildElements(ui.elements.detailsBody);
              // Menu
              if(state.showMenu){
                ui.composites.menu.show();
              } else{
                ui.composites.menu.hide();
              }
              // Details
              if(state.showDetails){
                ui.composites.details.show(true);
              } else{
                ui.composites.details.hide(true);
              }
              // Divs
              ui.composites.responsiveContainer.setInnerHeights();
              ui.composites.responsiveContainer.setOuterHeights();
              ui.composites.responsiveContainer.getInnerWidths();
            },

            getInnerWidths(){
              state.graphContainerWidth = parseInt(ui.elements.graphContainer.clientWidth);
              state.detailsContainerWidth = parseInt(ui.elements.detailsContainer.clientWidth);
            },

            getInnerHeights(){
              state.graphContainerHeight = parseInt(ui.elements.graphContainer.clientHeight);
              if(state.showDetails){
                state.detailsContainerHeight = parseInt(ui.elements.detailsContainer.clientHeight);
              }
            },

            setInnerHeights(){
              ui.elements.graphContainer.style.height = state.graphContainerHeight + "px";
              ui.elements.detailsContainer.style.height = state.detailsContainerHeight + "px";
            },

            setOuterHeights(){
              ui.elements.mainContainer.style.height = ui.elements.leftContainer.offsetHeight + "px";
            },

            getSizes(){
              ui.composites.responsiveContainer.getInnerWidths();
              ui.composites.responsiveContainer.getInnerHeights();
            },

            setSizes(){
              ui.composites.responsiveContainer.setInnerHeights();
              ui.composites.responsiveContainer.setOuterHeights();
            },

            adaptToResize(){
              ui.composites.responsiveContainer.getSizes();
              ui.composites.responsiveContainer.setSizes();
            },

            adaptToFullscreen(){
              ui.composites.responsiveContainer.getSizes();
              if(document.fullscreenElement){
                // On entering fullscreen, remember the current container heights
                state.beforeFullscreenGraphContainerHeight = state.graphContainerHeight;
                state.beforeFullscreenDetailsContainerHeight = state.detailsContainerHeight;
                // and then adapt them to maximum height possible in full screen mode
                function calculateFullscreenMaxGraphHeight(){
                  let outerHeight = null;
                  try{
                    const mainDivComputedStyle = window.getComputedStyle(ui.elements.mainContainer),
                      graphDivComputedStyle = window.getComputedStyle(ui.elements.graphContainer),
                      paddingTop = parseFloat(mainDivComputedStyle.paddingTop),
                      borderTop = parseFloat(graphDivComputedStyle.borderTopWidth),
                      borderBottom = parseFloat(graphDivComputedStyle.borderBottomWidth),
                      paddingBottom = parseFloat(mainDivComputedStyle.paddingBottom);
                    outerHeight = paddingTop + borderTop + borderBottom + paddingBottom;
                    if(!isFinite(outerHeight) || outerHeight === null){
                      throw "Invalid number";
                    }
                  } catch(e){
                    // Hard coded fallback, depends on CSS of containers (1px borders, 6px padding)
                    outerHeight = 1 + 3 + 3 + 1;
                  }
                  let graphHeight = screen.height - outerHeight;
                  if(state.showDetails){
                    graphHeight -= ui.composites.details.calculateHeightDifference();
                  }
                  return graphHeight;
                }
                state.graphContainerHeight = calculateFullscreenMaxGraphHeight();
              } else{
                // On leaving fullscreen, set container heights back to remembered values
                state.graphContainerHeight = state.beforeFullscreenGraphContainerHeight;
                state.detailsContainerHeight = state.beforeFullscreenDetailsContainerHeight;
              }
              ui.composites.responsiveContainer.setSizes();
            },
          },

          menu:{
            show(){
              ui.elements.leftContainer.style.width = "80%";
              ui.elements.rightContainer.style.width = "20%";
              ui.elements.rightContainer.style.display = "block";
            },

            hide(){
              ui.elements.leftContainer.style.width = "100%";
              ui.elements.rightContainer.style.width = "0%";
              ui.elements.rightContainer.style.display = "none";
            },

            toggle(){
              // Update menu button
              const div = ui.elements.menuToggleDiv;
              state.showMenu = !state.showMenu;
              if(state.showMenu){
                div.innerText = ui.symbols.menuShown;
                ui.composites.menu.show();
              } else {
                div.innerHTML = ui.symbols.menuHidden;
                ui.composites.menu.hide();
              }

              // Update rest of UI
              ui.composites.responsiveContainer.getInnerWidths();
              ui.composites.responsiveContainer.getInnerHeights();
              ui.composites.responsiveContainer.setOuterHeights();
              ui.composites.graph.updateGraphDrawingArea();
            },

            setItem(keyElement, valElement, toActive){
              const currentText = keyElement.innerHTML;
              let sliceStart = 0;
              if(currentText.startsWith(ui.symbols.menuItemActive)){
                sliceStart = ui.symbols.menuItemActive.length;
              } else if (currentText.startsWith(ui.symbols.menuItemInactive)){
                sliceStart = ui.symbols.menuItemInactive.length;
              }
              if(toActive){
                keyElement.innerHTML = ui.symbols.menuItemActive + currentText.slice(sliceStart);
                keyElement.style.backgroundColor = "#f5f5f5";
                keyElement.style.color = "black";
                keyElement.style.borderColor = "#999";
                keyElement.style.boxShadow = "0px 0px 3px rgba(0, 0, 0, 0.35)";
                valElement.style.display = "block";
              } else {
                keyElement.innerHTML = ui.symbols.menuItemInactive + currentText.slice(sliceStart);
                keyElement.style.backgroundColor = "white";
                keyElement.style.color = "#222";
                keyElement.style.borderColor = "#ccc";
                keyElement.style.boxShadow = "0px 0px 3px rgba(0, 0, 0, 0.2)";
                valElement.style.display = "none";
              }
            },

            toggleItem(keyElement, valElement){
              const toActive = !(valElement.style.display !== "none");
              ui.composites.menu.setItem(keyElement, valElement, toActive);
            },
          },

          details:{
            calculateHeightDifference(){
              let outerHeight = null;
              try{
                const graphContainerComputedStyle = window.getComputedStyle(ui.elements.graphContainer),
                  detailsContainerComputedStyle = window.getComputedStyle(ui.elements.detailsContainer),
                  border1 = parseFloat(graphContainerComputedStyle.borderBottomWidth),
                  margin = parseFloat(detailsContainerComputedStyle.marginTop),
                  border2 = parseFloat(detailsContainerComputedStyle.borderTopWidth);
                outerHeight = border1 + margin + border2;
                if(!isFinite(outerHeight) || outerHeight === null){
                  throw "Invalid number";
                }
              } catch(e){
                // Hard coded fallback, depends on CSS of containers (1px borders, 5px margin)
                outerHeight = 7.0;
              }
              return state.detailsContainerHeight + outerHeight
            },

            show(init=false){
              // Visibility
              ui.elements.detailsContainer.style.display = "block";
              if(!init){
                // Height
                const heightDiff = ui.composites.details.calculateHeightDifference();
                state.graphContainerHeight -= heightDiff;
                if(state.graphContainerHeight < 70){
                  state.graphContainerHeight = 70;
                }
                // Update rest of UI
                ui.composites.responsiveContainer.setSizes();
                ui.composites.graph.updateGraphDrawingArea();
              }
            },

            hide(init=false){
              // Visibility
              ui.elements.detailsContainer.style.display = "none";
              if(!init){
                // Height
                const heightDiff = ui.composites.details.calculateHeightDifference();
                state.graphContainerHeight += heightDiff;
                // Update rest of UI
                ui.composites.responsiveContainer.setSizes();
                ui.composites.graph.updateGraphDrawingArea();
              }
            },

            toggle(){
              // Update details button
              const toggleDiv = ui.elements.detailsToggleDiv;
              state.showDetails = !state.showDetails;
              if(state.showDetails){
                toggleDiv.innerText = ui.symbols.detailsShown;
                ui.composites.details.show();
              } else {
                toggleDiv.innerHTML = ui.symbols.detailsHidden;
                ui.composites.details.hide();
              }
            },
          },

          download:{
            png(filename){
              ui.composites.download._rasterImage(filename, "png");
            },

            jpg(filename){
              ui.composites.download._rasterImage(filename, "jpeg");
            },

            _rasterImage(filename, format){
              const canvas = ui.elements.graphContainer.getElementsByTagName("canvas")[0],
                mimeType = "image/" + format;
              function finishedBlobCallback(blob){
                ui.composites.download._blobToFileDownload(blob, filename);
              }
              try{
                // Blob to overcome size limitations for data URLs (e.g. 4MB in Chrome)
                canvas.toBlob(finishedBlobCallback, mimeType, 1.0);
              } catch(e){
                if(e.name === "SecurityError"){
                  alert("Image creation failed. Some images within the nodes of the graph can " +
                      "not be fetched from within JavaScript due to security settings of the " +
                      "server that provides the images.");
                } else{
                  throw e;
                }
              }
            },

            _blobToFileDownload(blob, filename){
              const url = URL.createObjectURL(blob),
                a = document.createElement("a");
              function handleClick(){
                setTimeout(function(){
                  // Long waiting time before removal for slow devices like mobile phones
                  URL.revokeObjectURL(url);
                  this.removeEventListener("click", handleClick);
                }, 20000);
              };
              document.body.appendChild(a);
              a.href = url;
              a.download = filename;
              a.addEventListener("click", handleClick, false);
              a.click();
              document.body.removeChild(a);
            },
          },

          selection(element, optionList, valueList=undefined) {
            while(element.hasChildNodes()){
              element.removeChild(element.firstChild);
            }
            for(let i=0; i<optionList.length; i++){
              let text = optionList[i];
              let value = text;
              if(valueList){
                value = valueList[i];
              }
              let opt = document.createElement("option");
              opt.appendChild(document.createTextNode(text));
              opt.value = value;
              element.appendChild(opt);
            }
          },

          tooltip:{
            show(xShift=null, yShift=null){
              if(isFinite(xShift) && xShift !== null){
                ui.elements.tooltipContainer.style.left =  parseInt(xShift) + "px";
              }
              if(isFinite(yShift) && yShift !== null){
                ui.elements.tooltipContainer.style.top = parseInt(yShift) + "px";
              }
              ui.elements.tooltipContainer.style.transition = "visibility 0s, opacity 0.1s";
              ui.elements.tooltipContainer.style.visibility = "visible";
              ui.elements.tooltipContainer.style.opacity = 1.0;
            },

            hide(){
              ui.elements.tooltipContainer.style.transition = "visibility 0.3s, opacity 0.3s ease-in";
              ui.elements.tooltipContainer.style.visibility = "hidden";
              ui.elements.tooltipContainer.style.opacity = 0.0;
            },
          },

          progressBar:{
            create(){
              // Main container
              this.mainContainer = document.createElement("div");
              this.mainContainer.id = "§RANDOM_ID§-progress-container";
              this.mainContainer.style.backgroundColor = state.shownData.general.background_color;
              ui.elements.graphContainer.style.backgroundColor = state.shownData.general.background_color;
              // Text container
              const numNodes = state.parsedData.nodes.length;
              this.textContainer = document.createElement("div");
              this.textContainer.innerText = "Large graph with " + numNodes + " nodes. Calculating an initial layout before visualizing it.";
              this.textContainer.style.textAlign = "center";
              // Bar container
              this.outerBarContainer = document.createElement("div");
              this.outerBarContainer.style.border = "1px solid black";
              this.outerBarContainer.style.borderRadius = "4px";
              this.outerBarContainer.style.marginTop = "1ex";
              this.outerBarContainer.style.padding = "1px";
              this.innerBarContainer = document.createElement("div");
              this.innerBarContainer.style.backgroundColor = "black";
              this.innerBarContainer.style.width = "0%";
              this.innerBarContainer.style.height = "8px";
              this.innerBarContainer.style.borderRadius = "3px";
              // Add them to DOM
              this.outerBarContainer.appendChild(this.innerBarContainer);
              this.mainContainer.appendChild(this.textContainer);
              this.mainContainer.appendChild(this.outerBarContainer);
              ui.elements.graphContainer.appendChild(this.mainContainer);
            },

            update(percentage){
              this.innerBarContainer.style.width = percentage + "%";
            },

            remove(){
              ui.elements.graphContainer.removeChild(this.mainContainer);
            }
          },

          graph:{
            createGraph(){
              // Remove existing elements
              ui.deleteChildElements(ui.elements.graphContainer);

              // Create new elements
              // I) Set graph options
              // a) Nodes: https://visjs.github.io/vis-network/docs/network/nodes.html
              const data = state.shownData,
                visNodes = [];
              let graphContainsFixedPositions = false;
              for(let i=0; i<data.nodes.length; i++){
                const node = data.nodes[i];
                let visNode = {
                  id: node.id,
                  shape: node.shape,
                  borderWidth: node.border_size,
                  color: {
                    background: node.color,
                    border: node.border_color,
                  },
                }
                // - Node labels
                if(state.showNodeLabels){
                  if(typeof(node.label) !== "undefined"){
                    visNode.label = node.label;
                    visNode.font = {
                      size: node.label_size,
                      color: node.label_color,
                      strokeWidth: (state.showNodeLabelBorders ? 1.2 : 0.0),
                      strokeColor: data.general.background_color,
                    }
                  }
                }
                // - Nodes hidden/shown ("hidden" property hides entire graph, using size=0 instead)
                if(state.showNodes || (typeof(node.image) !== "undefined" && state.showNodeImages)){
                  visNode.size = node.size;
                } else {
                  visNode.size = 0.0;
                }
                // - Node images
                if(typeof(node.image) !== "undefined"){
                  if(state.showNodeImages){
                    visNode.shape = "image";
                    visNode.image = node.image;
                    visNode.size = node.image_size;
                    // prevent a visual change of nodes with images upon selection (not deactivatable)
                    visNode.color.highlight = {
                      background: visNode.color.background,
                      border: visNode.color.border,
                    };
                    visNode.borderWidthSelected = visNode.borderWidth;
                  }
                }
                // - Node positions
                const x = node.fx,
                  y = node.fy;
                if((typeof(x) !== "undefined") || (typeof(y) !== "undefined")){
                  graphContainsFixedPositions = true;
                  visNode.fixed = {}
                  if(typeof(x) !== "undefined"){
                    visNode.x = x;
                    visNode.fixed.x = true;
                  }
                  if(typeof(y) !== "undefined"){
                    visNode.y = y;
                    visNode.fixed.y = true;
                  }
                }
                // - Node hover behavior 1: highlight neighborhood
                visNode.color.hover = {
                  background: visNode.color.background,
                  border: visNode.color.background,
                };
                // - Node hover behavior 2: show tooltip
                if(state.nodeHoverTooltip){
                  if(typeof(node.hover) !== "undefined"){
                    visNode.title = node.hover;
                  }
                }
                // - Node click behavior: show details
                if(typeof(node.click) !== "undefined" && node.click !== ""){
                  visNode.click = node.click;
                }
                visNodes.push(visNode);
              }

              // b) Edges: https://visjs.github.io/vis-network/docs/network/edges.html
              const visEdges = [];
              for(let i=0; i<data.edges.length; i++){
                const edge = data.edges[i];
                const visEdge = {
                  id: edge.id,
                  from: edge.source.id,
                  to: edge.target.id,
                  color: edge.color,
                  width: edge.size,
                };
                // - Edge labels
                if(state.showEdgeLabels){
                  if(typeof(edge.label) !== "undefined"){
                    visEdge.label = edge.label;
                    visEdge.font = {
                      size: edge.label_size,
                      color: edge.label_color,
                      strokeWidth: (state.showEdgeLabelBorders ? 1.2 : 0.0),
                      strokeColor: data.general.background_color,
                    }
                  }
                }
                // - Edges hidden/shown
                if(!state.showEdges){
                  visEdge.hidden = true;
                }
                // - Edge hover behavior
                if(state.edgeHoverTooltip){
                  if(typeof(edge.hover) !== "undefined") {
                    visEdge.title = edge.hover;
                  }
                }
                // - Edge click behavior
                if(typeof(edge.click) !== "undefined" && edge.click !== ""){
                  visEdge.click = edge.click;
                }
                visEdges.push(visEdge);
              }
              // c) Options: https://visjs.github.io/vis-network/docs/network/
              const options = {};
              // - Nodes
              options.nodes = {};
              options.nodes.chosen = false;
              options.nodes.imagePadding = 1.5;
              options.nodes.labelHighlightBold = false;
              options.nodes.shapeProperties = {};
              options.nodes.shapeProperties.useBorderWithImage = true;
              // - Node label font family
              if(state.nodeLabelFont !== null){
                options.nodes.font = {
                  "face": state.nodeLabelFont,
                }
              }
              // - Edges
              options.edges = {};
              // - Edges hidden/shown
              if(!state.showEdges){
                options.edges.hidden = true;
              }
              // - Edge curvature
              if(state.edgeCurvature === 0.0){
                options.edges.smooth = false;
              } else {
                options.edges.smooth = ui.composites.graph.calculateEdgeCurvatureOptions();
              }
              // - Edge arrows
              if(data.general.directed){
                options.edges.arrows = {};
                options.edges.arrows.to = {};
                options.edges.arrows.to.enabled = true;
                if(data.general.arrow_size !== 0.0){
                  options.edges.arrows.to.scaleFactor = data.general.arrow_size / 10.0;
                }
              }
              // - Edge label font family
              if(state.edgeLabelFont !== null){
                options.edges.font = {
                  "face": state.edgeLabelFont,
                }
              }
              // - Drawing area
              options.autoResize = false;
              // - Interaction
              options.interaction = {};
              options.interaction.selectable = false;
              options.interaction.selectConnectedEdges = false;
              options.interaction.tooltipDelay = 0.0;
              options.interaction.hover = state.nodeHoverNeighborhood;
              options.interaction.hoverConnectedEdges = state.nodeHoverNeighborhood;
              // - Layout algorithm
              const numNodes = state.parsedData.nodes.length;
              options.layout = {};
              if(numNodes < 400){
                options.layout.improvedLayout = true;
              } else{
                options.layout.improvedLayout = false;
              }
              options.physics = {};
              options.physics.barnesHut = {"damping": 0.25};
              options.physics.forceAtlas2Based = {"damping": 3.0};
              options.physics.repulsion = {};
              options.physics.hierarchicalRepulsion = {};
              options.physics.stabilization = {};
              options.physics.stabilization.enabled = false;
              if(numNodes > state.largeGraphThreshold){
                let numIterations = 800;
                if(numNodes >= 25000){
                  numIterations = 100;
                } else if(numNodes >= 10000){
                  numIterations = 300;
                } else if(numNodes >= 5000){
                  numIterations = 400;
                } else if(numNodes >= 2000){
                  numIterations = 500;
                } else if(numNodes >= 1000){
                  numIterations = 600;
                }
                options.physics.stabilization = {
                  "enabled": true,
                  "fit": true,
                  "iterations": numIterations,
                  "updateInterval": 1,
                };
              }
              // II) Create graph
              // - DataSet and Network: https://visjs.github.io/vis-network/docs/network
              state.visOptions = options;
              state.visData = {
                nodes: new vis.DataSet(visNodes),
                edges: new vis.DataSet(visEdges),
              };
              state.visGraph = new vis.Network(ui.elements.graphContainer, state.visData, state.visOptions);
              // III) Set further graph options after its creation
              // - Background: https://github.com/almende/vis/issues/2292
              state.visGraph.on("beforeDrawing", function(ctx){
                  ctx.save();
                  ctx.setTransform(1, 0, 0, 1, 0, 0);
                  ctx.fillStyle = data.general.background_color;
                  ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                  ctx.restore();
              })
              // - Node positions: node update after graph creation seems to prevent a bug
              if(graphContainsFixedPositions){
                state.visData.nodes.update(visNodes);
              }
              // - Graph behavior
              ui.composites.graph.setBehavior();

              // Menu toggle button
              if(state.showMenuToggleButton){
                const menuDiv = document.createElement("div");
                if(state.showMenu){
                  menuDiv.innerText = ui.symbols.menuShown;
                } else {
                  menuDiv.innerText = ui.symbols.menuHidden;
                }
                menuDiv.id = "§RANDOM_ID§-menu-toggle-button";
                menuDiv.onclick = ui.composites.menu.toggle;
                ui.elements.graphContainer.appendChild(menuDiv);
                ui.elements.menuToggleDiv = menuDiv;
              }
              // Details toggle button
              if(state.showDetailsToggleButton){
                const detailsDiv = document.createElement("div");
                if(state.showDetails){
                  detailsDiv.innerText = ui.symbols.detailsShown;
                } else {
                  detailsDiv.innerText = ui.symbols.detailsHidden;
                }
                detailsDiv.id = "§RANDOM_ID§-details-toggle-button";
                detailsDiv.onclick = ui.composites.details.toggle;
                ui.elements.graphContainer.appendChild(detailsDiv);
                ui.elements.detailsToggleDiv = detailsDiv;
              }
            },

            setBehavior(){
              // - Progress bar: only if large graph, stops simulation to get initial static image
              // https://visjs.github.io/vis-network/examples/network/exampleApplications/loadingBar.html
              const numNodes = state.parsedData.nodes.length;
              if(numNodes > state.largeGraphThreshold){
                // Layout start
                ui.composites.progressBar.create();
                // Layout update
                state.visGraph.on("stabilizationProgress", function(params){
                  var progressPercentage = params.iterations / params.total * 100;
                  ui.composites.progressBar.update(progressPercentage);
                });
                // Layout finished
                state.visGraph.once("stabilizationIterationsDone", function(){
                  setTimeout(function(){
                    ui.composites.progressBar.remove();
                    ui.composites.graph.simulationManager.stop();
                  }, 60);
                });
              }
              // - Node drag behavior: move node, fix its position or release it afterwards
              state.visGraph.on("dragStart", function(params){
                params.event = "[original event]";
                const nodeId = this.getNodeAt(params.pointer.DOM);
                if(nodeId){
                  const visNode = state.visData.nodes.get(nodeId),
                    position = state.visGraph.getPositions(nodeId);
                  visNode.x = position.x;
                  visNode.y = position.y;
                  visNode.fixed = false;
                  state.visData.nodes.update(visNode);
                }
              });
              state.visGraph.on("dragEnd", function(params){
                params.event = "[original event]";
                const nodeId = this.getNodeAt(params.pointer.DOM);
                if(nodeId){
                  if(state.nodeDragFix){
                    const visNode = state.visData.nodes.get(nodeId),
                      position = state.visGraph.getPositions(nodeId);
                    visNode.x = position.x;
                    visNode.y = position.y;
                    visNode.fixed = {"x": true, "y": true}
                    state.visData.nodes.update(visNode);
                  }
                }
              });
              // - Node and edge hover behavior: already covered
              // - Node and edge click behavior
              // https://visjs.github.io/vis-network/examples/network/events/interactionEvents.html
              function createNodeText(node){
                let htmlText = "<div>Node: " + String(node.id) + "</div>";
                if(typeof(node.click) !== "undefined" && node.click !== ""){
                  htmlText += '<div id="§RANDOM_ID§-details-user-provided">' + node.click + '</div>';
                }
                return htmlText;
              }
              function createEdgeText(edge){
                let htmlText = "<div>Edge: " + String(edge.id) + "</div>";
                if(typeof(edge.click) !== "undefined" && edge.click !== ""){
                  htmlText += '<div id="§RANDOM_ID§-details-user-provided">' + edge.click + '</div>';
                }
                return htmlText;
              }
              state.visGraph.on("click", function(params){
                params.event = "[original event]";
                let htmlText = "";
                const nodeId = this.getNodeAt(params.pointer.DOM);
                if(nodeId){
                  const node = state.visData.nodes.get(nodeId);
                  if(node){
                    htmlText = createNodeText(node);
                  }
                } else {
                  const edgeId = this.getEdgeAt(params.pointer.DOM);
                  if(edgeId){
                    const edge = state.visData.edges.get(edgeId);
                    if(edge){
                      htmlText = createEdgeText(edge);
                    }
                  }
                }
                ui.elements.detailsBody.innerHTML = htmlText;
              });
              // - Simulation behavior
              state.visGraph.on("startStabilizing", function(params){
                // A manually stopped simulation restarts automatically by dragging a node or
                // altering a dataset, immediately triggering this event. So if the simulation
                // shall be inactive, any automatic restart can be turned off immediately here.
                if(!state.layoutAlgorithmActive){
                  state.visGraph.stopSimulation();
                }
              });
              // Start (considers all simulation parameters)
              ui.composites.graph.simulationManager.start();
            },

            // Graph
            updateGraphDrawingArea(){
              state.visGraph.setSize(state.graphContainerWidth, state.graphContainerHeight);
              state.visGraph.redraw();
            },

            // Nodes
            updateNodes(){
              const data = state.shownData,
                newVisNodes = [];
              for(let i=0; i<data.nodes.length; i++){
                const node = data.nodes[i],
                  visNode = state.visData.nodes.get(node.id);
                // Node shape
                visNode.shape = node.shape;
                // Node size
                if(state.showNodes){
                  visNode.size = node.size;
                } else {
                  visNode.size = 0.0;
                }
                // Node images
                if(state.showNodeImages){
                  if(typeof(node.image) !== "undefined"){
                    visNode.size = node.image_size;
                    visNode.shape = "image";
                    visNode.image = node.image;
                  }
                }
                // Prevent node movements: Remove stored positions of nodes once fixed and now released
                if(visNode.fixed === false){
                  delete visNode.x;
                  delete visNode.y;
                }
                newVisNodes.push(visNode);
              }
              state.visData.nodes.update(newVisNodes);
            },

            preventNodeJump(visNode){
              if(visNode.fixed === false){
                delete visNode.x;
                delete visNode.y;
              }
            },

            updateNodeVisibilities(){
              ui.composites.graph.updateNodes();
            },

            updateNodeSizes(){
              const data = state.shownData,
                newVisNodes = [];
              for(let i=0; i<data.nodes.length; i++){
                const node = data.nodes[i],
                  visNode = state.visData.nodes.get(node.id);
                visNode.size = node.size;
                if(state.showNodeImages && typeof(node.image) !== "undefined"){
                  visNode.size = node.image_size;
                }
                ui.composites.graph.preventNodeJump(visNode);
                newVisNodes.push(visNode);
              }
              state.visData.nodes.update(newVisNodes);
            },

            updateNodeHoverNeighborhoodBehavior(){
              state.visOptions.interaction.hover = state.nodeHoverNeighborhood;
              state.visOptions.interaction.hoverConnectedEdges = state.nodeHoverNeighborhood;
              state.visGraph.setOptions(state.visOptions);
            },

            updateNodeHoverTooltipBehavior(){
              const data = state.shownData,
                newVisNodes = [];
              for(let i=0; i<data.nodes.length; i++){
                const node = data.nodes[i],
                  visNode = state.visData.nodes.get(node.id);
                if(typeof(node.hover) !== "undefined"){
                  visNode.title = state.nodeHoverTooltip ? node.hover : null;
                }
                newVisNodes.push(visNode);
              }
              state.visData.nodes.update(newVisNodes);
            },

            // Node images
            updateNodeImages(){
              const data = state.shownData,
                newVisNodes = [];
              for(let i=0; i<data.nodes.length; i++){
                const node = data.nodes[i],
                  visNode = state.visData.nodes.get(node.id);
                visNode.shape = node.shape;
                if(state.showNodes){
                  visNode.size = node.size;
                } else {
                  visNode.size = 0.0;
                }
                if(state.showNodeImages){
                  if(typeof(node.image) !== "undefined"){
                    visNode.size = node.image_size;
                    visNode.shape = "image";
                    visNode.image = node.image;
                  }
                }
                ui.composites.graph.preventNodeJump(visNode);
                newVisNodes.push(visNode);
              }
              state.visData.nodes.update(newVisNodes);
            },

            // Node labels
            updateNodeLabels(){
              // Vis data sets: https://visjs.github.io/vis-data/data/dataset.html
              const data = state.shownData,
                newVisNodes = [];
              for(let i=0; i<data.nodes.length; i++){
                const node = data.nodes[i];
                const visNode = state.visData.nodes.get(node.id);
                if(state.showNodeLabels){
                  visNode.label = node.label;
                  visNode.font = {
                    size: node.label_size,
                    color: node.label_color,
                    strokeWidth: (state.showNodeLabelBorders ? 1.2 : 0.0),
                    strokeColor: data.general.background_color,
                  }
                } else{
                  visNode.label = undefined;
                }
                ui.composites.graph.preventNodeJump(visNode);
                newVisNodes.push(visNode);
              }
              state.visData.nodes.update(newVisNodes);
            },

            // Edges
            calculateEdgeCurvatureOptions(){
              const appearanceAdaptionFactor = 0.5,
                options = {
                "type": state.edgeCurvature > 0.0 ? "curvedCW" : "curvedCCW",
                "roundness": Math.abs(state.edgeCurvature) * appearanceAdaptionFactor,
              };
              return options
            },

            updateEdgeVisibility(){
              const data = state.shownData,
                newVisEdges = [];
              for(let i=0; i<data.edges.length; i++){
                const edge = data.edges[i],
                  visEdge = state.visData.edges.get(edge.id);
                visEdge.hidden = !state.showEdges;
                newVisEdges.push(visEdge);
              }
              state.visData.edges.update(newVisEdges);
            },

            updateEdgeSizes(){
              const data = state.shownData,
                newVisEdges = [];
              for (let i=0; i<data.edges.length; i++){
                const edge = data.edges[i],
                  newVisEdge = state.visData.edges.get(edge.id);
                newVisEdge.width = edge.size;
                newVisEdges.push(newVisEdge);
              }
              state.visData.edges.update(newVisEdges);
            },

            updateEdgeCurvatures(){
              if(state.edgeCurvature === 0.0){
                state.visOptions.edges.smooth = false;
              } else {
                state.visOptions.edges.smooth = ui.composites.graph.calculateEdgeCurvatureOptions();
              }
              state.visGraph.setOptions(state.visOptions);
            },

            updateEdgeHoverTooltipBehavior(){
              /* Correct code, but there is a bug that renders null values as empty div (instead of ignoring them)
              const data = state.shownData,
                newVisEdges = [];
              for(let i=0; i<data.edges.length; i++){
                const edge = data.edges[i],
                  visEdge = state.visData.edges.get(edge.id);
                if(typeof(edge.hover) !== "undefined"){
                  visEdge.title = state.edgeHoverTooltip ? edge.hover : null;
                }
                newVisEdges.push(visEdge);
              }
              state.visData.edges.update(newVisEdges);
              */
              // Workaround code
              function cloneObject(obj){
                return Object.assign({}, obj);
              }
              const data = state.shownData,
                newVisEdges = [];
              for(let i=0; i<data.edges.length; i++){
                const edge = data.edges[i],
                  visEdge = state.visData.edges.get(edge.id);
                if(typeof(edge.hover) !== "undefined"){
                  if(state.edgeHoverTooltip){
                    visEdge.title = edge.hover;
                    newVisEdges.push(visEdge);
                  } else{
                    // edges.update can only add properties, not delete them, hence use of clone/remove/add
                    clonedEdge = cloneObject(visEdge);
                    delete clonedEdge.title;
                    state.visData.edges.remove(edge.id);
                    state.visData.edges.add(clonedEdge);
                  }
                }
              }
              if(state.edgeHoverTooltip){
                state.visData.edges.update(newVisEdges);
              }
            },

            // Edge labels
            updateEdgeLabels(){
              const data = state.shownData,
                newVisEdges = [],
                noLabel = " ";  // undefined, null, "" or deleting label property does not work
              for(let i=0; i<data.edges.length; i++){
                const edge = data.edges[i],
                  visEdge = state.visData.edges.get(edge.id);
                if(state.showEdgeLabels){
                  visEdge.label = edge.label;
                  visEdge.font = {
                    size: edge.label_size,
                    color: edge.label_color,
                    strokeWidth: (state.showEdgeLabelBorders ? 1.2 : 0.0),
                    strokeColor: data.general.background_color,
                  }
                } else {
                  visEdge.label = noLabel;
                }
                newVisEdges.push(visEdge);
              }
              state.visData.edges.update(newVisEdges);
            },

            // Layout algorithm
            simulationManager:{
              start(){
                state.visGraph.startSimulation();
                this.setAlgorithm();
                this.setSpringLength();
                this.setSpringConstant();
                this.setCentralGravity();
                this.setGravitationalConstant();
                this.setAvoidOverlap();
              },
              stop(){
                state.visGraph.stopSimulation();
              },
              setActivity(on){
                if(on){
                  this.start();
                } else{
                  this.stop();
                }
              },
              setAlgorithm(){
                const name = state.layoutAlgorithm;
                state.visOptions.physics.solver = name;
                state.visGraph.setOptions(state.visOptions);
                if(name === "repulsion"){
                  ui.elements.avoidOverlapContainer.style.opacity = ui.convert.boolToOpacity(false);
                  ui.elements.gravitationalConstantContainer.style.opacity = ui.convert.boolToOpacity(false);
                } else if(name === "hierarchicalRepulsion"){
                  ui.elements.avoidOverlapContainer.style.opacity = ui.convert.boolToOpacity(true);
                  ui.elements.gravitationalConstantContainer.style.opacity = ui.convert.boolToOpacity(false);
                } else {
                  ui.elements.avoidOverlapContainer.style.opacity = ui.convert.boolToOpacity(true);
                  ui.elements.gravitationalConstantContainer.style.opacity = ui.convert.boolToOpacity(true);
                }
              },
              releaseFixedNodes(){
                const data = state.shownData,
                  newVisNodes = [];
                for(let i=0; i<data.nodes.length; i++){
                  const node = data.nodes[i],
                    visNode = state.visData.nodes.get(node.id);
                  ui.composites.graph.preventNodeJump(visNode);
                  visNode.fixed = false;
                  // Note: Deletion of x, y and fixed may work too, but .update does not delete props
                  newVisNodes.push(visNode);
                }
                state.visData.nodes.update(newVisNodes);
              },
              setSpringLength(){
                state.visOptions.physics.barnesHut.springLength = state.springLength;
                state.visOptions.physics.forceAtlas2Based.springLength = state.springLength;
                state.visOptions.physics.repulsion.springLength = state.springLength;
                state.visOptions.physics.hierarchicalRepulsion.springLength = state.springLength;
                state.visGraph.setOptions(state.visOptions);
              },
              setSpringConstant(){
                state.visOptions.physics.barnesHut.springConstant = state.springConstant / 10.0;
                state.visOptions.physics.forceAtlas2Based.springConstant = state.springConstant;
                state.visOptions.physics.repulsion.springConstant = state.springConstant;
                state.visOptions.physics.hierarchicalRepulsion.springConstant = state.springConstant;
                state.visGraph.setOptions(state.visOptions);
              },
              setCentralGravity(){
                state.visOptions.physics.barnesHut.centralGravity = state.centralGravity;
                state.visOptions.physics.forceAtlas2Based.centralGravity = state.centralGravity / 100.0;
                state.visOptions.physics.repulsion.centralGravity = state.centralGravity;
                state.visOptions.physics.hierarchicalRepulsion.centralGravity = state.centralGravity;
                state.visGraph.setOptions(state.visOptions);
              },
              setGravitationalConstant(){
                state.visOptions.physics.barnesHut.gravitationalConstant = state.gravitationalConstant;
                state.visOptions.physics.forceAtlas2Based.gravitationalConstant = state.gravitationalConstant / 10.0;
                // Not a parameter in repulsion and hierarchicalRepulsion
                state.visGraph.setOptions(state.visOptions);
              },
              setAvoidOverlap(){
                state.visOptions.physics.barnesHut.avoidOverlap = state.avoidOverlap;
                state.visOptions.physics.forceAtlas2Based.avoidOverlap = state.avoidOverlap;
                // Not a parameter in repulsion and hierarchicalRepulsion
                state.visGraph.setOptions(state.visOptions);
              },
            }
          },
        },

        init(){
          // Containers
          ui.composites.responsiveContainer.init();
          // Graph selection (only visible if multiple graphs in data)
          if(state.rawData.length > 1){
            ui.elements.graphSelectionContainer.style.display = ui.convert.boolToDisplayStyle(true);
            const optionList = [],
              valueList = [];
            let label;
            for(let i=0; i<state.rawData.length; i++){
              const graph = state.rawData[i];
              try{
                label = String(graph.label);
                if(label === "undefined" || label === ""){
                  throw "Invalid label";
                }
              } catch(e){
                label = "Unnamed graph";
              }
              const name = String(i+1) + ": " + label;
              optionList.push(name);
              valueList.push(String(i));
            }
            ui.composites.selection(ui.elements.graphSelection, optionList, valueList);
          }
          // General (menu item)
          ui.composites.menu.setItem(ui.elements.generalHead, ui.elements.generalBody, true);
          // Data selection (menu item)
          ui.composites.menu.setItem(ui.elements.dataHead, ui.elements.dataBody, false);
          // - Node size
          ui.elements.nodeSizeNormalizationCheckbox.checked = state.useNodeSizeNormalization;
          ui.elements.nodeSizeNormalizationContainer.style.display = ui.convert.boolToDisplayStyle(state.useNodeSizeNormalization);
          ui.elements.nodeSizeNormalizationMinText.innerHTML = ui.convert.numberToText(state.nodeSizeNormalizationMin);
          ui.elements.nodeSizeNormalizationMinSlider.value = state.nodeSizeNormalizationMin;
          ui.elements.nodeSizeNormalizationMaxText.innerHTML = ui.convert.numberToText(state.nodeSizeNormalizationMax);
          ui.elements.nodeSizeNormalizationMaxSlider.value = state.nodeSizeNormalizationMax;
          // - Edge size
          ui.elements.edgeSizeNormalizationCheckbox.checked = state.useEdgeSizeNormalization;
          ui.elements.edgeSizeNormalizationContainer.style.display = ui.convert.boolToDisplayStyle(state.useEdgeSizeNormalization);
          ui.elements.edgeSizeNormalizationMinText.innerHTML = ui.convert.numberToText(state.edgeSizeNormalizationMin);
          ui.elements.edgeSizeNormalizationMinSlider.value = state.edgeSizeNormalizationMin;
          ui.elements.edgeSizeNormalizationMaxText.innerHTML = ui.convert.numberToText(state.edgeSizeNormalizationMax);
          ui.elements.edgeSizeNormalizationMaxSlider.value = state.edgeSizeNormalizationMax;
          // Nodes
          ui.composites.menu.setItem(ui.elements.nodeHead, ui.elements.nodeBody, false);
          ui.elements.nodeCheckbox.checked = state.showNodes;
          ui.elements.nodeSizeFactorText.innerHTML = ui.convert.numberToText(state.nodeSizeFactor);
          ui.elements.nodeSizeFactorSlider.value = state.nodeSizeFactor;
          ui.elements.nodeDragFixCheckbox.checked = state.nodeDragFix;
          ui.elements.nodeHoverNeighborhoodCheckbox.checked = state.nodeHoverNeighborhood;
          ui.elements.nodeHoverTooltipCheckbox.checked = state.nodeHoverTooltip;
          // Node images
          ui.composites.menu.setItem(ui.elements.nodeImageHead, ui.elements.nodeImageBody, false);
          ui.elements.nodeImageMetaControl.style.display = false;
          ui.elements.nodeImageCheckbox.checked = state.showNodeImages;
          ui.elements.nodeImageSizeFactorText.innerHTML = ui.convert.numberToText(state.nodeImageSizeFactor);
          ui.elements.nodeImageSizeFactorSlider.value = state.nodeImageSizeFactor;
          // Node labels
          ui.composites.menu.setItem(ui.elements.nodeLabelHead, ui.elements.nodeLabelBody, false);
          ui.elements.nodeLabelCheckbox.checked = state.showNodeLabels;
          ui.elements.nodeLabelBorderCheckbox.checked = state.showNodeLabelBorders;
          ui.elements.nodeLabelSizeFactorText.innerHTML = ui.convert.numberToText(state.nodeLabelSizeFactor);
          ui.elements.nodeLabelSizeFactorSlider.value = state.nodeLabelSizeFactor;
          ui.elements.nodeLabelRotationText.innerHTML = ui.convert.numberToText(state.nodeLabelRotation);
          ui.elements.nodeLabelRotationSlider.value = state.nodeLabelRotation;
          // Edges
          ui.composites.menu.setItem(ui.elements.edgeHead, ui.elements.edgeBody, false);
          ui.elements.edgeCheckbox.checked = state.showEdges;
          ui.elements.edgeSizeFactorText.innerHTML = ui.convert.numberToText(state.edgeSizeFactor);
          ui.elements.edgeSizeFactorSlider.value = state.edgeSizeFactor;
          ui.elements.edgeCurvatureText.innerHTML = ui.convert.numberToText(state.edgeCurvature);
          ui.elements.edgeCurvatureSlider.value = state.edgeCurvature;
          ui.elements.edgeHoverTooltipCheckbox.checked = state.edgeHoverTooltip;
          // Edge labels
          ui.composites.menu.setItem(ui.elements.edgeLabelHead, ui.elements.edgeLabelBody, false);
          ui.elements.edgeLabelCheckbox.checked = state.showEdgeLabels;
          ui.elements.edgeLabelBorderCheckbox.checked = state.showEdgeLabelBorders;
          ui.elements.edgeLabelSizeFactorText.innerHTML = ui.convert.numberToText(state.edgeLabelSizeFactor);
          ui.elements.edgeLabelSizeFactorSlider.value = state.edgeLabelSizeFactor;
          ui.elements.edgeLabelRotationText.innerHTML = ui.convert.numberToText(state.edgeLabelRotation);
          ui.elements.edgeLabelRotationSlider.value = state.edgeLabelRotation;
          // Layout algorithm
          ui.composites.menu.setItem(ui.elements.layoutAlgorithmHead, ui.elements.layoutAlgorithmBody, false);
          ui.elements.simulationCheckbox.checked = state.layoutAlgorithmActive;
          ui.elements.layoutAlgorithmSelection.value = state.layoutAlgorithm;
          ui.elements.centralGravitySlider.value = state.centralGravity;
          ui.elements.centralGravityText.innerHTML = ui.convert.numberToText(state.centralGravity);
          ui.elements.springLengthSlider.value = state.springLength;
          ui.elements.springLengthText.innerHTML = ui.convert.numberToText(state.springLength);
          ui.elements.springConstantSlider.value = state.springConstant;
          ui.elements.springConstantText.innerHTML = ui.convert.numberToText(state.springConstant);
          ui.elements.gravitationalConstantSlider.value = state.gravitationalConstant;
          ui.elements.gravitationalConstantText.innerHTML = ui.convert.numberToText(state.gravitationalConstant);
          ui.elements.avoidOverlapSlider.value = state.avoidOverlap;
          ui.elements.avoidOverlapText.innerHTML = ui.convert.numberToText(state.avoidOverlap);

          ui.initSelectionValues();
        },

        initSelectionValues(){
          function setSelectionOptionsAndValue(element, options, value, values=null){
            if(values === null){
              values = options;
            }
            if(!values.includes(value)){
              value = values[0];
            }
            ui.composites.selection(element, options, values);
            element.value = value;
          }
          // Node label text data source
          setSelectionOptionsAndValue(
            ui.elements.nodeLabelTextDataSourceSelect,
            state.parsedData.general.node_properties.node_label_text_data_sources,
            state.nodeLabelTextDataSource,
          );
          // Edge label text data source
          setSelectionOptionsAndValue(
            ui.elements.edgeLabelTextDataSourceSelect,
            state.parsedData.general.edge_properties.edge_label_text_data_sources,
            state.edgeLabelTextDataSource,
          );
          // Node size data source
          setSelectionOptionsAndValue(
            ui.elements.nodeSizeDataSourceSelect,
            state.parsedData.general.node_properties.node_size_data_sources,
            state.nodeSizeDataSource,
          );
          // Edge size data source
          setSelectionOptionsAndValue(
            ui.elements.edgeSizeDataSourceSelect,
            state.parsedData.general.edge_properties.edge_size_data_sources,
            state.edgeSizeDataSource,
          );
          // Layout algorithm
          setSelectionOptionsAndValue(
            ui.elements.layoutAlgorithmSelection,
            ["Barnes-Hut", "Force Atlas 2", "Repulsion", "Hierarchical repulsion"],
            state.layoutAlgorithm,
            ["barnesHut", "forceAtlas2Based", "repulsion", "hierarchicalRepulsion"],
          );
        },

        deleteChildElements(element){
          while(element.firstChild){
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management
            // As of 2019, it is not possible to explicitly or programmatically trigger
            // garbage collection in JavaScript.
            element.removeChild(element.firstChild);
          }
        },

        convert:{
          numberToText(number, numDigits=2) {
            return String(Number(number).toFixed(numDigits));
          },

          boolToDisplayStyle(isVisible){
            if(isVisible){
              return "block";
            }
            return "none";
          },

          boolToOpacity(isActive){
            if(isActive){
              return 1.0;
            }
            return 0.25;
          },

          boolToTooltipDelay(isActive){
            if(isActive){
              return 0;
            }
            return 100000000;
          },
        },

        setBehavior(){
          // Window resize (includes ctrl+wheel zoom, landscape/portrait orientation on phones)
          window.onresize = function(){
            ui.composites.responsiveContainer.adaptToResize();
            ui.composites.graph.updateGraphDrawingArea();
          }
          // Container resize
          ui.elements.graphContainer.onmouseup = function(){
            const currentHeight = parseInt(ui.elements.graphContainer.clientHeight);
            if(currentHeight != state.graphContainerHeight){
              ui.composites.responsiveContainer.adaptToResize();
              ui.composites.graph.updateGraphDrawingArea();
            }
          };
          ui.elements.detailsContainer.onmouseup = function(){
            const currentHeight = parseInt(ui.elements.detailsContainer.clientHeight);
            if(currentHeight != state.detailsContainerHeight){
              ui.composites.responsiveContainer.adaptToResize();
            }
          };
          // Tooltip
          ui.elements.tooltipContainer.onmouseover = function(){
            ui.composites.tooltip.show();
          }
          ui.elements.tooltipContainer.onmouseout = function(){
            ui.composites.tooltip.hide();
          }
          // General menu
          ui.elements.generalHead.onclick = function(){
            ui.composites.menu.toggleItem(ui.elements.generalHead, ui.elements.generalBody);
          };
          ui.elements.resetButton.onclick = function(){
            app.restart();
          };
          ui.elements.fullscreenButton.onclick = function(){
            if(document.fullscreenElement){
              document.exitFullscreen();
            } else{
              ui.elements.mainContainer.requestFullscreen()
                .catch(function(err){
                  alert("Error attempting to enable full-screen mode: " + err.message);
                });
            }
          };
          ui.elements.mainContainer.onfullscreenchange = function(){
            if(document.fullscreenElement){
              ui.elements.fullscreenButton.innerText = "Exit full screen";
            } else{
              ui.elements.fullscreenButton.innerText = "Enter full screen";
            }
            // Wait for browser to switch to fullscreen and resize divs, then adapt to new sizes
            setTimeout(function(){
              ui.composites.responsiveContainer.adaptToFullscreen();
              ui.composites.graph.updateGraphDrawingArea();
            }, 250);
          };
          ui.elements.pngExportButton.onclick = function(){
            ui.composites.download.png("graph.png");
          };
          ui.elements.jpgExportButton.onclick = function(){
            ui.composites.download.jpg("graph.jpg");
          };
          // Data menu
          ui.elements.dataHead.onclick = function(){
            ui.composites.menu.toggleItem(ui.elements.dataHead, ui.elements.dataBody);
          };
          // - Graph selection
          ui.elements.graphSelection.onchange = function(){
            const chosenGraphIndex = parseInt(this.value);
            state.manager.parseChosenData(chosenGraphIndex);
            state.manager.prepareShownData();
            ui.initSelectionValues();
            ui.composites.graph.createGraph();
          };
          // - Node label text
          ui.elements.nodeLabelTextDataSourceSelect.onchange = function(){
            state.nodeLabelTextDataSource = this.value;
            state.manager.updateNodeLabelTexts();
          };
          // - Edge label text
          ui.elements.edgeLabelTextDataSourceSelect.onchange = function(){
            state.edgeLabelTextDataSource = this.value;
            state.manager.updateEdgeLabelTexts();
          };
          // - Node size
          ui.elements.nodeSizeDataSourceSelect.onchange = function(){
            state.nodeSizeDataSource = this.value;
            state.manager.updateNodeSizes();
          };
          ui.elements.nodeSizeNormalizationCheckbox.onchange = function(){
            state.useNodeSizeNormalization = this.checked;
            ui.elements.nodeSizeNormalizationContainer.style.display = ui.convert.boolToDisplayStyle(state.useNodeSizeNormalization);
            state.manager.updateNodeSizes();
          };
          ui.elements.nodeSizeNormalizationMinSlider.oninput = function(){
            ui.elements.nodeSizeNormalizationMinText.innerHTML = ui.convert.numberToText(this.value);
          };
          ui.elements.nodeSizeNormalizationMinSlider.onchange = function(){
            state.nodeSizeNormalizationMin = parseFloat(this.value);
            if(state.nodeSizeNormalizationMin > state.nodeSizeNormalizationMax){
              state.nodeSizeNormalizationMax = state.nodeSizeNormalizationMin;
              ui.elements.nodeSizeNormalizationMaxSlider.value = state.nodeSizeNormalizationMax;
              ui.elements.nodeSizeNormalizationMaxText.innerHTML = ui.convert.numberToText(state.nodeSizeNormalizationMax);
            }
            state.manager.updateNodeSizes();
          };
          ui.elements.nodeSizeNormalizationMaxSlider.oninput = function(){
            ui.elements.nodeSizeNormalizationMaxText.innerHTML = ui.convert.numberToText(this.value);
          };
          ui.elements.nodeSizeNormalizationMaxSlider.onchange = function(){
            state.nodeSizeNormalizationMax = parseFloat(this.value);
            if(state.nodeSizeNormalizationMax < state.nodeSizeNormalizationMin){
              state.nodeSizeNormalizationMin = state.nodeSizeNormalizationMax;
              ui.elements.nodeSizeNormalizationMinSlider.value = state.nodeSizeNormalizationMin;
              ui.elements.nodeSizeNormalizationMinText.innerHTML = ui.convert.numberToText(state.nodeSizeNormalizationMin);
            }
            state.manager.updateNodeSizes();
          };
          // - Edge size
          ui.elements.edgeSizeDataSourceSelect.onchange = function(){
            state.edgeSizeDataSource = this.value;
            state.manager.updateEdgeSizes();
          };
          ui.elements.edgeSizeNormalizationCheckbox.onchange = function(){
            state.useEdgeSizeNormalization = this.checked;
            ui.elements.edgeSizeNormalizationContainer.style.display = ui.convert.boolToDisplayStyle(state.useEdgeSizeNormalization);
            state.manager.updateEdgeSizes();
          };
          ui.elements.edgeSizeNormalizationMinSlider.oninput = function(){
            ui.elements.edgeSizeNormalizationMinText.innerHTML = ui.convert.numberToText(this.value);
          };
          ui.elements.edgeSizeNormalizationMinSlider.onchange = function(){
            state.edgeSizeNormalizationMin = parseFloat(this.value);
            if(state.edgeSizeNormalizationMin > state.edgeSizeNormalizationMax){
              state.edgeSizeNormalizationMax = state.edgeSizeNormalizationMin;
              ui.elements.edgeSizeNormalizationMaxSlider.value = state.edgeSizeNormalizationMax;
              ui.elements.edgeSizeNormalizationMaxText.innerHTML = ui.convert.numberToText(state.edgeSizeNormalizationMax);
            }
            state.manager.updateEdgeSizes();
          };
          ui.elements.edgeSizeNormalizationMaxSlider.oninput = function(){
            ui.elements.edgeSizeNormalizationMaxText.innerHTML = ui.convert.numberToText(this.value);
          };
          ui.elements.edgeSizeNormalizationMaxSlider.onchange = function(){
            state.edgeSizeNormalizationMax = parseFloat(this.value);
            if(state.edgeSizeNormalizationMax < state.edgeSizeNormalizationMin){
              state.edgeSizeNormalizationMin = state.edgeSizeNormalizationMax;
              ui.elements.edgeSizeNormalizationMinSlider.value = state.edgeSizeNormalizationMin;
              ui.elements.edgeSizeNormalizationMinText.innerHTML = ui.convert.numberToText(state.edgeSizeNormalizationMin);
            }
            state.manager.updateEdgeSizes();
          };
          // Nodes menu
          ui.elements.nodeHead.onclick = function(){
            ui.composites.menu.toggleItem(ui.elements.nodeHead, ui.elements.nodeBody);
          };
          ui.elements.nodeCheckbox.onchange = function(){
            state.showNodes = this.checked;
            ui.composites.graph.updateNodeVisibilities();
          };
          ui.elements.nodeSizeFactorSlider.oninput = function(){
            ui.elements.nodeSizeFactorText.innerHTML = ui.convert.numberToText(this.value);
          };
          ui.elements.nodeSizeFactorSlider.onchange = function(){
            state.nodeSizeFactor = parseFloat(this.value);
            state.manager.updateNodeSizes();
          };
          ui.elements.nodeDragFixCheckbox.onchange = function(){
            state.nodeDragFix = this.checked;
          };
          ui.elements.nodeHoverNeighborhoodCheckbox.onchange = function(){
            state.nodeHoverNeighborhood = this.checked;
            ui.composites.graph.updateNodeHoverNeighborhoodBehavior();
          };
          ui.elements.nodeHoverTooltipCheckbox.onchange = function(){
            state.nodeHoverTooltip = this.checked;
            ui.composites.graph.updateNodeHoverTooltipBehavior();
          };
          ui.elements.nodeReleaseButton.onclick = function(){
            ui.composites.graph.simulationManager.releaseFixedNodes();
          };
          // Node images menu
          ui.elements.nodeImageHead.onclick = function(){
            ui.composites.menu.toggleItem(ui.elements.nodeImageHead, ui.elements.nodeImageBody);
          };
          ui.elements.nodeImageCheckbox.onchange = function(){
            state.showNodeImages = this.checked;
            state.manager.updateNodeImages();
          };
          ui.elements.nodeImageSizeFactorSlider.oninput = function(){
            ui.elements.nodeImageSizeFactorText.innerHTML = ui.convert.numberToText(this.value);
          };
          ui.elements.nodeImageSizeFactorSlider.onchange = function(){
            state.nodeImageSizeFactor = parseFloat(this.value);
            state.manager.updateNodeImages();
          };
          // Node labels menu
          ui.elements.nodeLabelHead.onclick = function(){
            ui.composites.menu.toggleItem(ui.elements.nodeLabelHead, ui.elements.nodeLabelBody);
          };
          ui.elements.nodeLabelCheckbox.onchange = function(){
            state.showNodeLabels = this.checked;
            ui.composites.graph.updateNodeLabels();
          };
          ui.elements.nodeLabelBorderCheckbox.onchange = function(){
            state.showNodeLabelBorders = this.checked;
            ui.composites.graph.updateNodeLabels();
          };
          ui.elements.nodeLabelSizeFactorSlider.oninput = function(){
            ui.elements.nodeLabelSizeFactorText.innerHTML = ui.convert.numberToText(this.value);
          };
          ui.elements.nodeLabelSizeFactorSlider.onchange = function(){
            state.nodeLabelSizeFactor = parseFloat(this.value);
            state.manager.updateNodeLabelSizes();
          };
          // Edges menu
          ui.elements.edgeHead.onclick = function(){
            ui.composites.menu.toggleItem(ui.elements.edgeHead, ui.elements.edgeBody);
          };
          ui.elements.edgeCheckbox.onchange = function(){
            state.showEdges = this.checked;
            ui.composites.graph.updateEdgeVisibility();
          };
          ui.elements.edgeSizeFactorSlider.oninput = function(){
            ui.elements.edgeSizeFactorText.innerHTML = ui.convert.numberToText(this.value);
          };
          ui.elements.edgeSizeFactorSlider.onchange = function(){
            state.edgeSizeFactor = parseFloat(this.value);
            state.manager.updateEdgeSizes();
          };
          ui.elements.edgeCurvatureSlider.oninput = function(){
            ui.elements.edgeCurvatureText.innerHTML = ui.convert.numberToText(this.value);
          };
          ui.elements.edgeCurvatureSlider.onchange = function(){
            state.edgeCurvature = parseFloat(this.value);
            state.manager.updateEdgeCurvatures();
          };
          ui.elements.edgeHoverTooltipCheckbox.onchange = function(){
            state.edgeHoverTooltip = this.checked;
            ui.composites.graph.updateEdgeHoverTooltipBehavior();
          };
          // Edge labels menu
          ui.elements.edgeLabelHead.onclick = function(){
            ui.composites.menu.toggleItem(ui.elements.edgeLabelHead, ui.elements.edgeLabelBody);
          };
          ui.elements.edgeLabelCheckbox.onchange = function(){
            state.showEdgeLabels = this.checked;
            ui.composites.graph.updateEdgeLabels();
          };
          ui.elements.edgeLabelBorderCheckbox.onchange = function(){
            state.showEdgeLabelBorders = this.checked;
            ui.composites.graph.updateEdgeLabels();
          };
          ui.elements.edgeLabelSizeFactorSlider.oninput = function(){
            ui.elements.edgeLabelSizeFactorText.innerHTML = ui.convert.numberToText(this.value);
          };
          ui.elements.edgeLabelSizeFactorSlider.onchange = function(){
            state.edgeLabelSizeFactor = parseFloat(this.value);
            state.manager.updateEdgeLabelSizes();
          };
          // Layout algorithm menu
          ui.elements.layoutAlgorithmHead.onclick = function(){
            ui.composites.menu.toggleItem(ui.elements.layoutAlgorithmHead, ui.elements.layoutAlgorithmBody);
          };
          ui.elements.simulationCheckbox.onchange = function(){
            state.layoutAlgorithmActive = !state.layoutAlgorithmActive;
            ui.composites.graph.simulationManager.setActivity(state.layoutAlgorithmActive);
          };
          ui.elements.layoutAlgorithmSelection.onchange = function(){
            state.layoutAlgorithm = this.value;
            ui.composites.graph.simulationManager.setAlgorithm();
          };
          ui.elements.centralGravitySlider.oninput = function(){
            ui.elements.centralGravityText.innerHTML = ui.convert.numberToText(this.value);
          };
          ui.elements.centralGravitySlider.onchange = function(){
            state.centralGravity = parseFloat(this.value);
            ui.composites.graph.simulationManager.setCentralGravity();
          };
          ui.elements.springLengthSlider.oninput = function(){
            ui.elements.springLengthText.innerHTML = ui.convert.numberToText(this.value);
          };
          ui.elements.springLengthSlider.onchange = function(){
            state.springLength = parseFloat(this.value);
            ui.composites.graph.simulationManager.setSpringLength();
          };
          ui.elements.springConstantSlider.oninput = function(){
            ui.elements.springConstantText.innerHTML = ui.convert.numberToText(this.value);
          };
          ui.elements.springConstantSlider.onchange = function(){
            state.springConstant = parseFloat(this.value);
            ui.composites.graph.simulationManager.setSpringConstant();
          };
          ui.elements.gravitationalConstantSlider.oninput = function(){
            ui.elements.gravitationalConstantText.innerHTML = ui.convert.numberToText(this.value);
          };
          ui.elements.gravitationalConstantSlider.onchange = function(){
            state.gravitationalConstant = parseFloat(this.value);
            ui.composites.graph.simulationManager.setGravitationalConstant();
          };
          ui.elements.avoidOverlapSlider.oninput = function(){
            ui.elements.avoidOverlapText.innerHTML = ui.convert.numberToText(this.value);
          };
          ui.elements.avoidOverlapSlider.onchange = function(){
            state.avoidOverlap = parseFloat(this.value);
            ui.composites.graph.simulationManager.setAvoidOverlap();
          };
        },
      }

      const app = {
        start(){
          state.manager.fetchRawDataFromTemplating();
          state.manager.parseChosenData(0);
          state.manager.prepareShownData();
          ui.init();
          // Wait a bit to finish UI rendering, then start potentially slow layout computation
          setTimeout(function(){
            ui.composites.graph.createGraph();
            ui.setBehavior();
          }, 400);
          // Reduce risk of getting stuck with a wrong drawing area size
          function checkIfSizeUpdateRequired(){
            if(ui.elements.graphContainer.clientWidth != state.graphContainerWidth){
              ui.composites.responsiveContainer.adaptToResize();
              ui.composites.graph.updateGraphDrawingArea();
            }
          }
          [1, 2, 5, 8, 12, 15, 20, 25, 30, 35, 40, 45, 50, 60, 90].forEach(function(delay){
            setTimeout(checkIfSizeUpdateRequired, delay*1000);
          })
        },

        restart(){
          app.start();
        },
      }

      // Start website dynamics
      app.start();
    });
  </script>
§SUFFIX§
